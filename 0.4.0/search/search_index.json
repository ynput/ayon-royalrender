{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"index.html","title":"RoyalRender addon","text":"<p>RoyalRender integration for AYON.</p>"},{"location":"index.html#installation","title":"Installation","text":"<p>Files from <code>ayon-royalrender/client/ayon_royalrender/rr_root/render_apps</code> needs to be copied to <code>RR_ROOT</code>.</p> <p>Each render node needs to have AYON Launcher executable installed. Default location is set in <code>rrConfig.AYON</code>.</p>"},{"location":"index.html#expected-environment-variables-set-on-render-nodes","title":"Expected environment variables set on Render nodes","text":"<p>Render jobs needs to get environment variables set and controlled by AYON for particular render node. For this reason <code>injection</code> of environment variables process is triggered for each of the nodes. Process runs <code>ayon_console --headless extractenvironments PATH_TO_EXTRACTED_FILE</code>.</p> <p>For this it needs to now location of <code>ayon_console</code> which should be get from config of AYON rrApp, but currently it is not technically possible.</p> <p>So each render node need to have these environment variables set: - AYON_SERVER_URL (http://localhost:5000) - AYON_API_KEY (api key of newly created service account in AYON) - AYON_EXECUTABLE (path to ayon_console on this particular machine)</p>"},{"location":"license.html","title":"License","text":"<pre><code>                             Apache License\n                       Version 2.0, January 2004\n                    http://www.apache.org/licenses/\n</code></pre> <p>TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION</p> <ol> <li> <p>Definitions.</p> <p>\"License\" shall mean the terms and conditions for use, reproduction,   and distribution as defined by Sections 1 through 9 of this document.</p> <p>\"Licensor\" shall mean the copyright owner or entity authorized by   the copyright owner that is granting the License.</p> <p>\"Legal Entity\" shall mean the union of the acting entity and all   other entities that control, are controlled by, or are under common   control with that entity. For the purposes of this definition,   \"control\" means (i) the power, direct or indirect, to cause the   direction or management of such entity, whether by contract or   otherwise, or (ii) ownership of fifty percent (50%) or more of the   outstanding shares, or (iii) beneficial ownership of such entity.</p> <p>\"You\" (or \"Your\") shall mean an individual or Legal Entity   exercising permissions granted by this License.</p> <p>\"Source\" form shall mean the preferred form for making modifications,   including but not limited to software source code, documentation   source, and configuration files.</p> <p>\"Object\" form shall mean any form resulting from mechanical   transformation or translation of a Source form, including but   not limited to compiled object code, generated documentation,   and conversions to other media types.</p> <p>\"Work\" shall mean the work of authorship, whether in Source or   Object form, made available under the License, as indicated by a   copyright notice that is included in or attached to the work   (an example is provided in the Appendix below).</p> <p>\"Derivative Works\" shall mean any work, whether in Source or Object   form, that is based on (or derived from) the Work and for which the   editorial revisions, annotations, elaborations, or other modifications   represent, as a whole, an original work of authorship. For the purposes   of this License, Derivative Works shall not include works that remain   separable from, or merely link (or bind by name) to the interfaces of,   the Work and Derivative Works thereof.</p> <p>\"Contribution\" shall mean any work of authorship, including   the original version of the Work and any modifications or additions   to that Work or Derivative Works thereof, that is intentionally   submitted to Licensor for inclusion in the Work by the copyright owner   or by an individual or Legal Entity authorized to submit on behalf of   the copyright owner. For the purposes of this definition, \"submitted\"   means any form of electronic, verbal, or written communication sent   to the Licensor or its representatives, including but not limited to   communication on electronic mailing lists, source code control systems,   and issue tracking systems that are managed by, or on behalf of, the   Licensor for the purpose of discussing and improving the Work, but   excluding communication that is conspicuously marked or otherwise   designated in writing by the copyright owner as \"Not a Contribution.\"</p> <p>\"Contributor\" shall mean Licensor and any individual or Legal Entity   on behalf of whom a Contribution has been received by Licensor and   subsequently incorporated within the Work.</p> </li> <li> <p>Grant of Copyright License. Subject to the terms and conditions of       this License, each Contributor hereby grants to You a perpetual,       worldwide, non-exclusive, no-charge, royalty-free, irrevocable       copyright license to reproduce, prepare Derivative Works of,       publicly display, publicly perform, sublicense, and distribute the       Work and such Derivative Works in Source or Object form.</p> </li> <li> <p>Grant of Patent License. Subject to the terms and conditions of       this License, each Contributor hereby grants to You a perpetual,       worldwide, non-exclusive, no-charge, royalty-free, irrevocable       (except as stated in this section) patent license to make, have made,       use, offer to sell, sell, import, and otherwise transfer the Work,       where such license applies only to those patent claims licensable       by such Contributor that are necessarily infringed by their       Contribution(s) alone or by combination of their Contribution(s)       with the Work to which such Contribution(s) was submitted. If You       institute patent litigation against any entity (including a       cross-claim or counterclaim in a lawsuit) alleging that the Work       or a Contribution incorporated within the Work constitutes direct       or contributory patent infringement, then any patent licenses       granted to You under this License for that Work shall terminate       as of the date such litigation is filed.</p> </li> <li> <p>Redistribution. You may reproduce and distribute copies of the       Work or Derivative Works thereof in any medium, with or without       modifications, and in Source or Object form, provided that You       meet the following conditions:</p> <p>(a) You must give any other recipients of the Work or       Derivative Works a copy of this License; and</p> <p>(b) You must cause any modified files to carry prominent notices       stating that You changed the files; and</p> <p>(c) You must retain, in the Source form of any Derivative Works       that You distribute, all copyright, patent, trademark, and       attribution notices from the Source form of the Work,       excluding those notices that do not pertain to any part of       the Derivative Works; and</p> <p>(d) If the Work includes a \"NOTICE\" text file as part of its       distribution, then any Derivative Works that You distribute must       include a readable copy of the attribution notices contained       within such NOTICE file, excluding those notices that do not       pertain to any part of the Derivative Works, in at least one       of the following places: within a NOTICE text file distributed       as part of the Derivative Works; within the Source form or       documentation, if provided along with the Derivative Works; or,       within a display generated by the Derivative Works, if and       wherever such third-party notices normally appear. The contents       of the NOTICE file are for informational purposes only and       do not modify the License. You may add Your own attribution       notices within Derivative Works that You distribute, alongside       or as an addendum to the NOTICE text from the Work, provided       that such additional attribution notices cannot be construed       as modifying the License.</p> <p>You may add Your own copyright statement to Your modifications and   may provide additional or different license terms and conditions   for use, reproduction, or distribution of Your modifications, or   for any such Derivative Works as a whole, provided Your use,   reproduction, and distribution of the Work otherwise complies with   the conditions stated in this License.</p> </li> <li> <p>Submission of Contributions. Unless You explicitly state otherwise,       any Contribution intentionally submitted for inclusion in the Work       by You to the Licensor shall be under the terms and conditions of       this License, without any additional terms or conditions.       Notwithstanding the above, nothing herein shall supersede or modify       the terms of any separate license agreement you may have executed       with Licensor regarding such Contributions.</p> </li> <li> <p>Trademarks. This License does not grant permission to use the trade       names, trademarks, service marks, or product names of the Licensor,       except as required for reasonable and customary use in describing the       origin of the Work and reproducing the content of the NOTICE file.</p> </li> <li> <p>Disclaimer of Warranty. Unless required by applicable law or       agreed to in writing, Licensor provides the Work (and each       Contributor provides its Contributions) on an \"AS IS\" BASIS,       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or       implied, including, without limitation, any warranties or conditions       of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A       PARTICULAR PURPOSE. You are solely responsible for determining the       appropriateness of using or redistributing the Work and assume any       risks associated with Your exercise of permissions under this License.</p> </li> <li> <p>Limitation of Liability. In no event and under no legal theory,       whether in tort (including negligence), contract, or otherwise,       unless required by applicable law (such as deliberate and grossly       negligent acts) or agreed to in writing, shall any Contributor be       liable to You for damages, including any direct, indirect, special,       incidental, or consequential damages of any character arising as a       result of this License or out of the use or inability to use the       Work (including but not limited to damages for loss of goodwill,       work stoppage, computer failure or malfunction, or any and all       other commercial damages or losses), even if such Contributor       has been advised of the possibility of such damages.</p> </li> <li> <p>Accepting Warranty or Additional Liability. While redistributing       the Work or Derivative Works thereof, You may choose to offer,       and charge a fee for, acceptance of support, warranty, indemnity,       or other liability obligations and/or rights consistent with this       License. However, in accepting such obligations, You may act only       on Your own behalf and on Your sole responsibility, not on behalf       of any other Contributor, and only if You agree to indemnify,       defend, and hold each Contributor harmless for any liability       incurred by, or claims asserted against, such Contributor by reason       of your accepting any such warranty or additional liability.</p> </li> </ol> <p>END OF TERMS AND CONDITIONS</p> <p>APPENDIX: How to apply the Apache License to your work.</p> <pre><code>  To apply the Apache License to your work, attach the following\n  boilerplate notice, with the fields enclosed by brackets \"[]\"\n  replaced with your own identifying information. (Don't include\n  the brackets!)  The text should be enclosed in the appropriate\n  comment syntax for the file format. We also recommend that a\n  file or class name and description of purpose be included on the\n  same \"printed page\" as the copyright notice for easier\n  identification within third-party archives.\n</code></pre> <p>Copyright [yyyy][name of copyright owner]</p> <p>Licensed under the Apache License, Version 2.0 (the \"License\");    you may not use this file except in compliance with the License.    You may obtain a copy of the License at</p> <pre><code>   http://www.apache.org/licenses/LICENSE-2.0\n</code></pre> <p>Unless required by applicable law or agreed to in writing, software    distributed under the License is distributed on an \"AS IS\" BASIS,    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.    See the License for the specific language governing permissions and    limitations under the License.</p>"},{"location":"autoapi/summary.html","title":"Summary","text":"<ul> <li>client<ul> <li>ayon_royalrender<ul> <li>addon</li> <li>api</li> <li>lib</li> <li>plugins<ul> <li>publish<ul> <li>collect_royalrender_job_nev_vars</li> <li>collect_rr_path_from_instance</li> <li>collect_sequences_from_job</li> <li>create_maya_cache_royalrender_job</li> <li>create_maya_royalrender_job</li> <li>create_nuke_royalrender_job</li> <li>create_publish_royalrender_job</li> <li>submit_jobs_to_royalrender</li> </ul> </li> </ul> </li> <li>rr_job</li> <li>rr_root<ul> <li>render_apps<ul> <li>scripts<ul> <li>ayon_inject_envvar</li> <li>ayon_remote_publish</li> </ul> </li> </ul> </li> </ul> </li> <li>version</li> </ul> </li> </ul> </li> <li>server<ul> <li>settings</li> </ul> </li> </ul>"},{"location":"autoapi/client/ayon_royalrender/index.html","title":"ayon_royalrender","text":""},{"location":"autoapi/client/ayon_royalrender/index.html#client.ayon_royalrender.RoyalRenderAddon","title":"<code>RoyalRenderAddon</code>","text":"<p>               Bases: <code>AYONAddon</code>, <code>IPluginPaths</code></p> <p>Class providing basic Royal Render implementation logic.</p> Source code in <code>client/ayon_royalrender/addon.py</code> <pre><code>class RoyalRenderAddon(AYONAddon, IPluginPaths):\n    \"\"\"Class providing basic Royal Render implementation logic.\"\"\"\n    name = \"royalrender\"\n    version = __version__\n\n    def initialize(self, studio_settings):\n        # type: (dict) -&gt; None\n        self.enabled = False\n        addon_settings = studio_settings.get(self.name)\n        if addon_settings:\n            self.enabled = addon_settings[\"enabled\"]\n\n    @staticmethod\n    def get_plugin_paths():\n        # type: () -&gt; dict\n        \"\"\"Royal Render plugin paths.\n\n        Returns:\n            dict: Dictionary of plugin paths for RR.\n        \"\"\"\n        current_dir = os.path.dirname(os.path.abspath(__file__))\n        return {\n            \"publish\": [os.path.join(current_dir, \"plugins\", \"publish\")]\n        }\n</code></pre>"},{"location":"autoapi/client/ayon_royalrender/index.html#client.ayon_royalrender.RoyalRenderAddon.get_plugin_paths","title":"<code>get_plugin_paths()</code>  <code>staticmethod</code>","text":"<p>Royal Render plugin paths.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>Dictionary of plugin paths for RR.</p> Source code in <code>client/ayon_royalrender/addon.py</code> <pre><code>@staticmethod\ndef get_plugin_paths():\n    # type: () -&gt; dict\n    \"\"\"Royal Render plugin paths.\n\n    Returns:\n        dict: Dictionary of plugin paths for RR.\n    \"\"\"\n    current_dir = os.path.dirname(os.path.abspath(__file__))\n    return {\n        \"publish\": [os.path.join(current_dir, \"plugins\", \"publish\")]\n    }\n</code></pre>"},{"location":"autoapi/client/ayon_royalrender/addon.html","title":"addon","text":"<p>Module providing support for Royal Render.</p>"},{"location":"autoapi/client/ayon_royalrender/addon.html#client.ayon_royalrender.addon.RoyalRenderAddon","title":"<code>RoyalRenderAddon</code>","text":"<p>               Bases: <code>AYONAddon</code>, <code>IPluginPaths</code></p> <p>Class providing basic Royal Render implementation logic.</p> Source code in <code>client/ayon_royalrender/addon.py</code> <pre><code>class RoyalRenderAddon(AYONAddon, IPluginPaths):\n    \"\"\"Class providing basic Royal Render implementation logic.\"\"\"\n    name = \"royalrender\"\n    version = __version__\n\n    def initialize(self, studio_settings):\n        # type: (dict) -&gt; None\n        self.enabled = False\n        addon_settings = studio_settings.get(self.name)\n        if addon_settings:\n            self.enabled = addon_settings[\"enabled\"]\n\n    @staticmethod\n    def get_plugin_paths():\n        # type: () -&gt; dict\n        \"\"\"Royal Render plugin paths.\n\n        Returns:\n            dict: Dictionary of plugin paths for RR.\n        \"\"\"\n        current_dir = os.path.dirname(os.path.abspath(__file__))\n        return {\n            \"publish\": [os.path.join(current_dir, \"plugins\", \"publish\")]\n        }\n</code></pre>"},{"location":"autoapi/client/ayon_royalrender/addon.html#client.ayon_royalrender.addon.RoyalRenderAddon.get_plugin_paths","title":"<code>get_plugin_paths()</code>  <code>staticmethod</code>","text":"<p>Royal Render plugin paths.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>Dictionary of plugin paths for RR.</p> Source code in <code>client/ayon_royalrender/addon.py</code> <pre><code>@staticmethod\ndef get_plugin_paths():\n    # type: () -&gt; dict\n    \"\"\"Royal Render plugin paths.\n\n    Returns:\n        dict: Dictionary of plugin paths for RR.\n    \"\"\"\n    current_dir = os.path.dirname(os.path.abspath(__file__))\n    return {\n        \"publish\": [os.path.join(current_dir, \"plugins\", \"publish\")]\n    }\n</code></pre>"},{"location":"autoapi/client/ayon_royalrender/api.html","title":"api","text":"<p>Wrapper around Royal Render API.</p>"},{"location":"autoapi/client/ayon_royalrender/api.html#client.ayon_royalrender.api.Api","title":"<code>Api</code>","text":"Source code in <code>client/ayon_royalrender/api.py</code> <pre><code>class Api:\n\n    _settings = None\n    RR_SUBMIT_CONSOLE = 1\n    RR_SUBMIT_API = 2\n\n    def __init__(self, rr_path=None):\n        self.log = Logger.get_logger(\"RoyalRender\")\n        self._rr_path = rr_path\n        os.environ[\"RR_ROOT\"] = rr_path\n\n    @staticmethod\n    def get_rr_bin_path(rr_root, tool_name=None):\n        # type: (str, str) -&gt; str\n        \"\"\"Get path to RR bin folder.\n\n        Args:\n            tool_name (str): Name of RR executable you want.\n            rr_root (str): Custom RR root if needed.\n\n        Returns:\n            str: Path to the tool based on current platform.\n\n        \"\"\"\n        is_64bit_python = sys.maxsize &gt; 2 ** 32\n\n        rr_bin_parts = [rr_root, \"bin\"]\n        if sys.platform.lower() == \"win32\":\n            rr_bin_parts.append(\"win\")\n\n        if sys.platform.lower() == \"darwin\":\n            rr_bin_parts.append(\"mac\")\n\n        if sys.platform.lower().startswith(\"linux\"):\n            rr_bin_parts.append(\"lx\")\n\n        rr_bin_path = os.sep.join(rr_bin_parts)\n\n        paths_to_check = []\n        # if we use 64bit python, append 64bit specific path first\n        if is_64bit_python:\n            if not tool_name:\n                return rr_bin_path + \"64\"\n            paths_to_check.append(rr_bin_path + \"64\")\n\n        # otherwise use 32bit\n        if not tool_name:\n            return rr_bin_path\n        paths_to_check.append(rr_bin_path)\n\n        return find_tool_in_custom_paths(paths_to_check, tool_name)\n\n    def _initialize_module_path(self):\n        # type: () -&gt; None\n        \"\"\"Set RR modules for Python.\"\"\"\n        # default for linux\n        rr_bin = self.get_rr_bin_path(self._rr_path)\n        rr_module_path = os.path.join(rr_bin, \"lx64/lib\")\n\n        if sys.platform.lower() == \"win32\":\n            rr_module_path = rr_bin\n            rr_module_path = rr_module_path.replace(\n                \"/\", os.path.sep\n            )\n\n        if sys.platform.lower() == \"darwin\":\n            rr_module_path = os.path.join(rr_bin, \"lib/python/27\")\n\n        sys.path.append(os.path.join(self._rr_path, rr_module_path))\n\n    @staticmethod\n    def create_submission(jobs, submitter_attributes):\n        # type: (list[RRJob], list[SubmitterParameter]) -&gt; SubmitFile\n        \"\"\"Create jobs submission file.\n\n        Args:\n            jobs (list): List of :class:`RRJob`\n            submitter_attributes (list): List of submitter attributes\n                :class:`SubmitterParameter` for whole submission batch.\n\n        Returns:\n            str: XML data of job submission files.\n\n        \"\"\"\n        return SubmitFile(SubmitterParameters=submitter_attributes, Jobs=jobs)\n\n    def submit_file(self, file, mode=RR_SUBMIT_CONSOLE):\n        # type: (SubmitFile, int) -&gt; None\n        if mode == self.RR_SUBMIT_CONSOLE:\n            self._submit_using_console(file)\n            return\n\n        # RR v7 supports only Python 2.7, so we bail out in fear\n        # until there is support for Python 3 \ud83d\ude30\n        raise NotImplementedError(\n            \"Submission via RoyalRender API is not supported yet\")\n        # self._submit_using_api(file)\n\n    def _submit_using_console(self, job_file):\n        # type: (SubmitFile) -&gt; None\n        rr_start_local = self.get_rr_bin_path(\n            self._rr_path, \"rrStartLocal\")\n\n        self.log.info(\"rr_console: {}\".format(rr_start_local))\n\n        args = [rr_start_local, \"rrSubmitterconsole\", job_file]\n        self.log.info(\"Executing: {}\".format(\" \".join(args)))\n        env = os.environ\n        env[\"RR_ROOT\"] = self._rr_path\n        run_subprocess(args, logger=self.log, env=env)\n\n    def _submit_using_api(self, file):\n        # type: (SubmitFile) -&gt; None\n        \"\"\"Use RR API to submit jobs.\n\n        Args:\n            file (SubmitFile): Submit jobs definition.\n\n        Throws:\n            RoyalRenderException: When something fails.\n\n        \"\"\"\n        self._initialize_module_path()\n        import libpyRR2 as rrLib  # noqa\n        from rrJob import getClass_JobBasics  # noqa\n        import libpyRR2 as _RenderAppBasic  # noqa\n\n        tcp = rrLib._rrTCP(\"\")  # noqa\n        rr_server = tcp.getRRServer()\n\n        if len(rr_server) == 0:\n            self.log.info(\"Got RR IP address {}\".format(rr_server))\n\n        # TODO: Port is hardcoded in RR? If not, move it to Settings\n        if not tcp.setServer(rr_server, 7773):\n            self.log.error(\n                \"Can not set RR server: {}\".format(tcp.errorMessage()))\n            raise RoyalRenderException(tcp.errorMessage())\n\n        # TODO: This need UI and better handling of username/password.\n        # We can't store password in keychain as it is pulled multiple\n        # times and users on linux must enter keychain password every time.\n        # Probably best way until we setup our own user management would be\n        # to encrypt password and save it to json locally. Not bulletproof\n        # but at least it is not stored in plaintext.\n        reg = AYONSettingsRegistry(\"rr_settings\")\n        try:\n            rr_user = reg.get_item(\"rr_username\")\n            rr_password = reg.get_item(\"rr_password\")\n        except ValueError:\n            # user has no rr credentials set\n            pass\n        else:\n            # login to RR\n            tcp.setLogin(rr_user, rr_password)\n\n        job = getClass_JobBasics()\n        renderer = _RenderAppBasic()\n\n        # iterate over SubmitFile, set _JobBasic (job) and renderer\n        # and feed it to jobSubmitNew()\n        # not implemented yet\n        job.renderer = renderer\n        tcp.jobSubmitNew(job)\n</code></pre>"},{"location":"autoapi/client/ayon_royalrender/api.html#client.ayon_royalrender.api.Api.create_submission","title":"<code>create_submission(jobs, submitter_attributes)</code>  <code>staticmethod</code>","text":"<p>Create jobs submission file.</p> <p>Parameters:</p> Name Type Description Default <code>jobs</code> <code>list</code> <p>List of :class:<code>RRJob</code></p> required <code>submitter_attributes</code> <code>list</code> <p>List of submitter attributes :class:<code>SubmitterParameter</code> for whole submission batch.</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>XML data of job submission files.</p> Source code in <code>client/ayon_royalrender/api.py</code> <pre><code>@staticmethod\ndef create_submission(jobs, submitter_attributes):\n    # type: (list[RRJob], list[SubmitterParameter]) -&gt; SubmitFile\n    \"\"\"Create jobs submission file.\n\n    Args:\n        jobs (list): List of :class:`RRJob`\n        submitter_attributes (list): List of submitter attributes\n            :class:`SubmitterParameter` for whole submission batch.\n\n    Returns:\n        str: XML data of job submission files.\n\n    \"\"\"\n    return SubmitFile(SubmitterParameters=submitter_attributes, Jobs=jobs)\n</code></pre>"},{"location":"autoapi/client/ayon_royalrender/api.html#client.ayon_royalrender.api.Api.get_rr_bin_path","title":"<code>get_rr_bin_path(rr_root, tool_name=None)</code>  <code>staticmethod</code>","text":"<p>Get path to RR bin folder.</p> <p>Parameters:</p> Name Type Description Default <code>tool_name</code> <code>str</code> <p>Name of RR executable you want.</p> <code>None</code> <code>rr_root</code> <code>str</code> <p>Custom RR root if needed.</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>Path to the tool based on current platform.</p> Source code in <code>client/ayon_royalrender/api.py</code> <pre><code>@staticmethod\ndef get_rr_bin_path(rr_root, tool_name=None):\n    # type: (str, str) -&gt; str\n    \"\"\"Get path to RR bin folder.\n\n    Args:\n        tool_name (str): Name of RR executable you want.\n        rr_root (str): Custom RR root if needed.\n\n    Returns:\n        str: Path to the tool based on current platform.\n\n    \"\"\"\n    is_64bit_python = sys.maxsize &gt; 2 ** 32\n\n    rr_bin_parts = [rr_root, \"bin\"]\n    if sys.platform.lower() == \"win32\":\n        rr_bin_parts.append(\"win\")\n\n    if sys.platform.lower() == \"darwin\":\n        rr_bin_parts.append(\"mac\")\n\n    if sys.platform.lower().startswith(\"linux\"):\n        rr_bin_parts.append(\"lx\")\n\n    rr_bin_path = os.sep.join(rr_bin_parts)\n\n    paths_to_check = []\n    # if we use 64bit python, append 64bit specific path first\n    if is_64bit_python:\n        if not tool_name:\n            return rr_bin_path + \"64\"\n        paths_to_check.append(rr_bin_path + \"64\")\n\n    # otherwise use 32bit\n    if not tool_name:\n        return rr_bin_path\n    paths_to_check.append(rr_bin_path)\n\n    return find_tool_in_custom_paths(paths_to_check, tool_name)\n</code></pre>"},{"location":"autoapi/client/ayon_royalrender/api.html#client.ayon_royalrender.api.RoyalRenderException","title":"<code>RoyalRenderException</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Exception used in various error states coming from RR.</p> Source code in <code>client/ayon_royalrender/api.py</code> <pre><code>class RoyalRenderException(Exception):\n    \"\"\"Exception used in various error states coming from RR.\"\"\"\n    pass\n</code></pre>"},{"location":"autoapi/client/ayon_royalrender/lib.html","title":"lib","text":"<p>Submitting render job to RoyalRender.</p>"},{"location":"autoapi/client/ayon_royalrender/lib.html#client.ayon_royalrender.lib.BaseCreateRoyalRenderJob","title":"<code>BaseCreateRoyalRenderJob</code>","text":"<p>               Bases: <code>InstancePlugin</code>, <code>AYONPyblishPluginMixin</code></p> <p>Creates separate rendering job for Royal Render</p> Source code in <code>client/ayon_royalrender/lib.py</code> <pre><code>class BaseCreateRoyalRenderJob(\n    pyblish.api.InstancePlugin, AYONPyblishPluginMixin\n):\n    \"\"\"Creates separate rendering job for Royal Render\"\"\"\n\n    label = \"Create Nuke Render job in RR\"\n    order = pyblish.api.IntegratorOrder + 0.1\n    hosts = [\"nuke\"]\n    families = [\"render\", \"prerender\"]\n    targets = [\"local\"]\n    optional = True\n\n    priority = 50\n    chunk_size = 1\n    concurrent_tasks = 1\n    use_gpu = True\n    use_published = True\n    auto_delete = True\n\n    @classmethod\n    def get_attribute_defs(cls):\n        return [\n            NumberDef(\n                \"priority\",\n                label=\"Priority\",\n                default=cls.priority,\n                decimals=0\n            ),\n            NumberDef(\n                \"chunk\",\n                label=\"Frames Per Task\",\n                default=cls.chunk_size,\n                decimals=0,\n                minimum=1,\n                maximum=1000\n            ),\n            NumberDef(\n                \"concurrency\",\n                label=\"Concurrency\",\n                default=cls.concurrent_tasks,\n                decimals=0,\n                minimum=1,\n                maximum=10\n            ),\n            BoolDef(\n                \"use_gpu\",\n                default=cls.use_gpu,\n                label=\"Use GPU\"\n            ),\n            BoolDef(\n                \"suspend_publish\",\n                default=False,\n                label=\"Suspend publish\"\n            ),\n            BoolDef(\n                \"use_published\",\n                default=cls.use_published,\n                label=\"Use published workfile\",\n            ),\n            BoolDef(\n                \"auto_delete\",\n                default=cls.auto_delete,\n                label=\"Cleanup temp renderfolder\",\n            ),\n        ]\n\n    def __init__(self, *args, **kwargs):\n        self._rr_root = None\n        self.scene_path = None\n        self.job = None\n        self.submission_parameters = None\n        self.rr_api = None\n\n    def process(self, instance):\n        if not instance.data.get(\"farm\"):\n            self.log.info(\"Skipping local instance.\")\n            return\n\n        instance.data[\"attributeValues\"] = self.get_attr_values_from_data(\n            instance.data\n        )\n\n        # add suspend_publish and auto_delete  attributeValue to instance data\n        instance.data[\"suspend_publish\"] = instance.data[\"attributeValues\"][\n            \"suspend_publish\"\n        ]\n        instance.data[\"auto_delete\"] = instance.data[\"attributeValues\"][\n            \"auto_delete\"\n        ]\n        instance.data[\"priority\"] = instance.data[\"attributeValues\"][\n            \"priority\"\n        ]\n\n        context = instance.context\n\n        self._rr_root = instance.data.get(\"rr_root\")\n        self.log.debug(self._rr_root)\n        if not self._rr_root:\n            raise KnownPublishError(\n                (\n                    \"Missing RoyalRender root. \"\n                    \"You need to configure RoyalRender module.\"\n                )\n            )\n\n        self.rr_api = rrApi(self._rr_root)\n\n        self.scene_path = context.data[\"currentFile\"]\n        if self.use_published:\n            published_workfile = get_published_workfile_instance(context)\n\n            # fallback if nothing was set\n            if published_workfile is None:\n                self.log.warning(\"Falling back to workfile\")\n                file_path = context.data[\"currentFile\"]\n            else:\n                workfile_repre = published_workfile.data[\"representations\"][0]\n                file_path = workfile_repre[\"published_path\"]\n\n            self.scene_path = file_path\n            self.log.info(\n                \"Using published scene for render {}\".format(self.scene_path)\n            )\n\n        if not instance.data.get(\"expectedFiles\"):\n            instance.data[\"expectedFiles\"] = []\n\n        if not instance.data.get(\"rrJobs\"):\n            instance.data[\"rrJobs\"] = []\n\n    def get_job(\n        self,\n        instance,\n        script_path,\n        render_path,\n        node_name,\n        single=False,\n        job_type=\"RENDER\"\n    ):\n        \"\"\"Get RR job based on current instance.\n\n        Args:\n            script_path (str): Path to Nuke script.\n            render_path (str): Output path.\n            node_name (str): Name of the render node.\n\n        Returns:\n            RRJob: RoyalRender Job instance.\n\n        \"\"\"\n        anatomy = instance.context.data[\"anatomy\"]\n        start_frame = int(instance.data[\"frameStartHandle\"])\n        end_frame = int(instance.data[\"frameEndHandle\"])\n        padding = anatomy.templates_obj.frame_padding\n\n        batch_name = os.path.basename(script_path)\n        jobname = \"%s - %s\" % (batch_name, instance.name)\n        if is_in_tests():\n            batch_name += datetime.now().strftime(\"%d%m%Y%H%M%S\")\n\n        render_dir = os.path.normpath(os.path.dirname(render_path))\n        output_filename_0 = self.pad_file_name(\n            render_path, str(start_frame), padding\n        )\n\n        file_name, file_ext = os.path.splitext(\n            os.path.basename(output_filename_0)\n        )\n\n        custom_attributes = []\n        job_disabled = \"1\" if instance.data[\"suspend_publish\"] is True else \"0\"\n        priority = instance.data[\"priority\"]\n\n        submitter_parameters_job = [\n            SubmitterParameter(\"SendJobDisabled\", \"1\", f\"{job_disabled}\"),\n            SubmitterParameter(\"Priority\", \"1\", f\"{priority}\"),\n        ]\n\n        # this will append expected files to instance as needed.\n        expected_files = self.expected_files(\n            instance, render_path, start_frame, end_frame\n        )\n        instance.data[\"expectedFiles\"].extend(expected_files)\n\n        render_dir = render_dir.replace(\"\\\\\", \"/\")\n\n        environment = get_instance_job_envs(instance)\n        environment.update(JobType[job_type].get_job_env())\n        environment = RREnvList(**environment)\n        environment_serialized = environment.serialize()\n\n        exported_env_script_path = f\"{render_dir}/rrEnv.allos\"\n        environment_serialized += rf'~~~[exec] \"&lt;rrLocalBin&gt;&lt;OsxApp rrPythonconsole&gt;\"  &lt;rrLocalRenderScripts&gt;ayon_inject_envvar.py -jid &lt;JID&gt; {exported_env_script_path}'\n        environment_serialized += rf'~~~[exec] {exported_env_script_path}'\n\n        job = RRJob(\n            Software=\"\",\n            Renderer=\"\",\n            SeqStart=int(start_frame),\n            SeqEnd=int(end_frame),\n            SeqStep=int(instance.data.get(\"byFrameStep\", 1)),\n            ImageFramePadding=padding,\n            SeqFileOffset=0,\n            Version=0,\n            SceneName=script_path,\n            IsActive=True,\n            ImageDir=render_dir,\n            ImageFilename=file_name,\n            ImageExtension=file_ext,\n            ImagePreNumberLetter=\"\",\n            ImageSingleOutputFile=single,\n            SceneOS=get_rr_platform(),\n            Layer=node_name,\n            SceneDatabaseDir=script_path,\n            CustomSHotName=jobname,\n            CompanyProjectName=instance.context.data[\"projectName\"],\n            ImageWidth=instance.data.get(\"resolutionWidth\"),\n            ImageHeight=instance.data.get(\"resolutionHeight\"),\n            CustomAttributes=custom_attributes,\n            SubmitterParameters=submitter_parameters_job,\n            rrEnvList=environment_serialized,\n        )\n\n        return job\n\n    def update_job_with_host_specific(self, instance, job):\n        \"\"\"Host specific mapping for RRJob\"\"\"\n        raise NotImplementedError\n\n    def expected_files(self, instance, path, start_frame, end_frame):\n        \"\"\"Get expected files.\n\n        This function generate expected files from provided\n        path and start/end frames.\n\n        It was taken from Deadline module, but this should be\n        probably handled better in collector to support more\n        flexible scenarios.\n\n        Args:\n            instance (Instance)\n            path (str): Output path.\n            start_frame (int): Start frame.\n            end_frame (int): End frame.\n\n        Returns:\n            list: List of expected files.\n\n        \"\"\"\n        dir_name = os.path.dirname(path)\n        file = os.path.basename(path)\n\n        expected_files = []\n\n        if \"#\" in file:\n            pparts = file.split(\"#\")\n            padding = \"%0{}d\".format(len(pparts) - 1)\n            file = pparts[0] + padding + pparts[-1]\n\n        if \"%\" not in file:\n            expected_files.append(path)\n            return expected_files\n\n        if instance.data.get(\"slate\"):\n            start_frame -= 1\n\n        expected_files.extend(\n            os.path.join(dir_name, (file % i)).replace(\"\\\\\", \"/\")\n            for i in range(start_frame, (end_frame + 1))\n        )\n        return expected_files\n\n    def pad_file_name(self, path, first_frame, padding):\n        \"\"\"Return output file path with #### for padding.\n\n        RR requires the path to be formatted with # in place of numbers.\n        For example `/path/to/render.####.png`\n\n        Args:\n            path (str): path to rendered image\n            first_frame (str): from representation to cleany replace with #\n                padding\n\n        Returns:\n            str\n\n        \"\"\"\n        self.log.debug(\"pad_file_name path: `{}`\".format(path))\n        self.log.debug(\"padding_from_anatatomy_preset: `{}`\".format(padding))\n        if \"%\" in path:\n            search_results = re.search(r\"(%0)(\\d)(d.)\", path).groups()\n            self.log.debug(\"_ search_results: `{}`\".format(search_results))\n            return int(search_results[1])\n        if \"#\" in path:\n            self.log.debug(\"already padded: `{}`\".format(path))\n            return path\n\n        if first_frame:\n            path = path.replace(str(first_frame).zfill(padding), \"#\" * padding)\n\n        return path\n</code></pre>"},{"location":"autoapi/client/ayon_royalrender/lib.html#client.ayon_royalrender.lib.BaseCreateRoyalRenderJob.expected_files","title":"<code>expected_files(instance, path, start_frame, end_frame)</code>","text":"<p>Get expected files.</p> <p>This function generate expected files from provided path and start/end frames.</p> <p>It was taken from Deadline module, but this should be probably handled better in collector to support more flexible scenarios.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Output path.</p> required <code>start_frame</code> <code>int</code> <p>Start frame.</p> required <code>end_frame</code> <code>int</code> <p>End frame.</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>List of expected files.</p> Source code in <code>client/ayon_royalrender/lib.py</code> <pre><code>def expected_files(self, instance, path, start_frame, end_frame):\n    \"\"\"Get expected files.\n\n    This function generate expected files from provided\n    path and start/end frames.\n\n    It was taken from Deadline module, but this should be\n    probably handled better in collector to support more\n    flexible scenarios.\n\n    Args:\n        instance (Instance)\n        path (str): Output path.\n        start_frame (int): Start frame.\n        end_frame (int): End frame.\n\n    Returns:\n        list: List of expected files.\n\n    \"\"\"\n    dir_name = os.path.dirname(path)\n    file = os.path.basename(path)\n\n    expected_files = []\n\n    if \"#\" in file:\n        pparts = file.split(\"#\")\n        padding = \"%0{}d\".format(len(pparts) - 1)\n        file = pparts[0] + padding + pparts[-1]\n\n    if \"%\" not in file:\n        expected_files.append(path)\n        return expected_files\n\n    if instance.data.get(\"slate\"):\n        start_frame -= 1\n\n    expected_files.extend(\n        os.path.join(dir_name, (file % i)).replace(\"\\\\\", \"/\")\n        for i in range(start_frame, (end_frame + 1))\n    )\n    return expected_files\n</code></pre>"},{"location":"autoapi/client/ayon_royalrender/lib.html#client.ayon_royalrender.lib.BaseCreateRoyalRenderJob.get_job","title":"<code>get_job(instance, script_path, render_path, node_name, single=False, job_type='RENDER')</code>","text":"<p>Get RR job based on current instance.</p> <p>Parameters:</p> Name Type Description Default <code>script_path</code> <code>str</code> <p>Path to Nuke script.</p> required <code>render_path</code> <code>str</code> <p>Output path.</p> required <code>node_name</code> <code>str</code> <p>Name of the render node.</p> required <p>Returns:</p> Name Type Description <code>RRJob</code> <p>RoyalRender Job instance.</p> Source code in <code>client/ayon_royalrender/lib.py</code> <pre><code>def get_job(\n    self,\n    instance,\n    script_path,\n    render_path,\n    node_name,\n    single=False,\n    job_type=\"RENDER\"\n):\n    \"\"\"Get RR job based on current instance.\n\n    Args:\n        script_path (str): Path to Nuke script.\n        render_path (str): Output path.\n        node_name (str): Name of the render node.\n\n    Returns:\n        RRJob: RoyalRender Job instance.\n\n    \"\"\"\n    anatomy = instance.context.data[\"anatomy\"]\n    start_frame = int(instance.data[\"frameStartHandle\"])\n    end_frame = int(instance.data[\"frameEndHandle\"])\n    padding = anatomy.templates_obj.frame_padding\n\n    batch_name = os.path.basename(script_path)\n    jobname = \"%s - %s\" % (batch_name, instance.name)\n    if is_in_tests():\n        batch_name += datetime.now().strftime(\"%d%m%Y%H%M%S\")\n\n    render_dir = os.path.normpath(os.path.dirname(render_path))\n    output_filename_0 = self.pad_file_name(\n        render_path, str(start_frame), padding\n    )\n\n    file_name, file_ext = os.path.splitext(\n        os.path.basename(output_filename_0)\n    )\n\n    custom_attributes = []\n    job_disabled = \"1\" if instance.data[\"suspend_publish\"] is True else \"0\"\n    priority = instance.data[\"priority\"]\n\n    submitter_parameters_job = [\n        SubmitterParameter(\"SendJobDisabled\", \"1\", f\"{job_disabled}\"),\n        SubmitterParameter(\"Priority\", \"1\", f\"{priority}\"),\n    ]\n\n    # this will append expected files to instance as needed.\n    expected_files = self.expected_files(\n        instance, render_path, start_frame, end_frame\n    )\n    instance.data[\"expectedFiles\"].extend(expected_files)\n\n    render_dir = render_dir.replace(\"\\\\\", \"/\")\n\n    environment = get_instance_job_envs(instance)\n    environment.update(JobType[job_type].get_job_env())\n    environment = RREnvList(**environment)\n    environment_serialized = environment.serialize()\n\n    exported_env_script_path = f\"{render_dir}/rrEnv.allos\"\n    environment_serialized += rf'~~~[exec] \"&lt;rrLocalBin&gt;&lt;OsxApp rrPythonconsole&gt;\"  &lt;rrLocalRenderScripts&gt;ayon_inject_envvar.py -jid &lt;JID&gt; {exported_env_script_path}'\n    environment_serialized += rf'~~~[exec] {exported_env_script_path}'\n\n    job = RRJob(\n        Software=\"\",\n        Renderer=\"\",\n        SeqStart=int(start_frame),\n        SeqEnd=int(end_frame),\n        SeqStep=int(instance.data.get(\"byFrameStep\", 1)),\n        ImageFramePadding=padding,\n        SeqFileOffset=0,\n        Version=0,\n        SceneName=script_path,\n        IsActive=True,\n        ImageDir=render_dir,\n        ImageFilename=file_name,\n        ImageExtension=file_ext,\n        ImagePreNumberLetter=\"\",\n        ImageSingleOutputFile=single,\n        SceneOS=get_rr_platform(),\n        Layer=node_name,\n        SceneDatabaseDir=script_path,\n        CustomSHotName=jobname,\n        CompanyProjectName=instance.context.data[\"projectName\"],\n        ImageWidth=instance.data.get(\"resolutionWidth\"),\n        ImageHeight=instance.data.get(\"resolutionHeight\"),\n        CustomAttributes=custom_attributes,\n        SubmitterParameters=submitter_parameters_job,\n        rrEnvList=environment_serialized,\n    )\n\n    return job\n</code></pre>"},{"location":"autoapi/client/ayon_royalrender/lib.html#client.ayon_royalrender.lib.BaseCreateRoyalRenderJob.pad_file_name","title":"<code>pad_file_name(path, first_frame, padding)</code>","text":"<p>Return output file path with #### for padding.</p> <p>RR requires the path to be formatted with # in place of numbers. For example <code>/path/to/render.####.png</code></p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>path to rendered image</p> required <code>first_frame</code> <code>str</code> <p>from representation to cleany replace with # padding</p> required <p>Returns:</p> Type Description <p>str</p> Source code in <code>client/ayon_royalrender/lib.py</code> <pre><code>def pad_file_name(self, path, first_frame, padding):\n    \"\"\"Return output file path with #### for padding.\n\n    RR requires the path to be formatted with # in place of numbers.\n    For example `/path/to/render.####.png`\n\n    Args:\n        path (str): path to rendered image\n        first_frame (str): from representation to cleany replace with #\n            padding\n\n    Returns:\n        str\n\n    \"\"\"\n    self.log.debug(\"pad_file_name path: `{}`\".format(path))\n    self.log.debug(\"padding_from_anatatomy_preset: `{}`\".format(padding))\n    if \"%\" in path:\n        search_results = re.search(r\"(%0)(\\d)(d.)\", path).groups()\n        self.log.debug(\"_ search_results: `{}`\".format(search_results))\n        return int(search_results[1])\n    if \"#\" in path:\n        self.log.debug(\"already padded: `{}`\".format(path))\n        return path\n\n    if first_frame:\n        path = path.replace(str(first_frame).zfill(padding), \"#\" * padding)\n\n    return path\n</code></pre>"},{"location":"autoapi/client/ayon_royalrender/lib.html#client.ayon_royalrender.lib.BaseCreateRoyalRenderJob.update_job_with_host_specific","title":"<code>update_job_with_host_specific(instance, job)</code>","text":"<p>Host specific mapping for RRJob</p> Source code in <code>client/ayon_royalrender/lib.py</code> <pre><code>def update_job_with_host_specific(self, instance, job):\n    \"\"\"Host specific mapping for RRJob\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"autoapi/client/ayon_royalrender/lib.html#client.ayon_royalrender.lib.get_instance_job_envs","title":"<code>get_instance_job_envs(instance)</code>","text":"<p>Add all job environments as specified on the instance and context.</p> <p>Any instance <code>job_env</code> vars will override the context <code>job_env</code> vars.</p> Source code in <code>client/ayon_royalrender/lib.py</code> <pre><code>def get_instance_job_envs(instance) -&gt; \"dict[str, str]\":\n    \"\"\"Add all job environments as specified on the instance and context.\n\n    Any instance `job_env` vars will override the context `job_env` vars.\n    \"\"\"\n    # Avoid import from 'ayon_core.pipeline'\n    from ayon_core.pipeline.publish import FARM_JOB_ENV_DATA_KEY\n\n    env = {}\n    for job_env in [\n        instance.context.data.get(FARM_JOB_ENV_DATA_KEY, {}),\n        instance.data.get(FARM_JOB_ENV_DATA_KEY, {})\n    ]:\n        if job_env:\n            env.update(job_env)\n\n    # Return the dict sorted just for readability in future logs\n    if env:\n        env = dict(sorted(env.items()))\n\n    return env\n</code></pre>"},{"location":"autoapi/client/ayon_royalrender/rr_job.html","title":"rr_job","text":"<p>Python wrapper for RoyalRender XML job file.</p>"},{"location":"autoapi/client/ayon_royalrender/rr_job.html#client.ayon_royalrender.rr_job.RREnvList","title":"<code>RREnvList</code>","text":"<p>               Bases: <code>dict</code></p> Source code in <code>client/ayon_royalrender/rr_job.py</code> <pre><code>class RREnvList(dict):\n    def serialize(self):\n        # &lt;rrEnvList&gt;VariableA=ValueA~~~VariableB=ValueB&lt;/rrEnvList&gt;\n        return \"~~~\".join(\n            [\"{}={}\".format(k, v) for k, v in sorted(self.items())])\n\n    @staticmethod\n    def parse(data):\n        # type: (str) -&gt; RREnvList\n        \"\"\"Parse rrEnvList string and return it as RREnvList object.\"\"\"\n        out = RREnvList()\n        for var in data.split(\"~~~\"):\n            if \"=\" in var:\n                k, v = var.split(\"=\", maxsplit=1)\n                out[k] = v\n        return out\n</code></pre>"},{"location":"autoapi/client/ayon_royalrender/rr_job.html#client.ayon_royalrender.rr_job.RREnvList.parse","title":"<code>parse(data)</code>  <code>staticmethod</code>","text":"<p>Parse rrEnvList string and return it as RREnvList object.</p> Source code in <code>client/ayon_royalrender/rr_job.py</code> <pre><code>@staticmethod\ndef parse(data):\n    # type: (str) -&gt; RREnvList\n    \"\"\"Parse rrEnvList string and return it as RREnvList object.\"\"\"\n    out = RREnvList()\n    for var in data.split(\"~~~\"):\n        if \"=\" in var:\n            k, v = var.split(\"=\", maxsplit=1)\n            out[k] = v\n    return out\n</code></pre>"},{"location":"autoapi/client/ayon_royalrender/rr_job.html#client.ayon_royalrender.rr_job.RRJob","title":"<code>RRJob</code>","text":"<p>               Bases: <code>object</code></p> <p>Mapping of Royal Render job file to a data class.</p> Source code in <code>client/ayon_royalrender/rr_job.py</code> <pre><code>@attr.s\nclass RRJob(object):\n    \"\"\"Mapping of Royal Render job file to a data class.\"\"\"\n\n    # Required\n    # --------\n\n    # Name of your render application. Same as in the render config file.\n    # (Maya, Houdini, Nuke)\n    Software = attr.ib()  # type: str\n\n    # The OS the scene was created on, all texture paths are set on\n    # that OS. Possible values are windows, linux, osx\n    SceneOS = attr.ib()  # type: Literal[\"windows\", \"linux\", \"osx\", \"win\", \"lx\", \"mac\"]\n\n    # Renderer you use. Same as in the render config file\n    # (VRay, Mental Ray, Arnold)\n    Renderer = attr.ib()  # type: str\n\n    # Version you want to render with. (5.11, 2010, 12)\n    Version = attr.ib()  # type: str\n\n    # Name of the scene file with full path.\n    SceneName = attr.ib()  # type: str\n\n    # Is the job enabled for submission?\n    # enabled by default\n    IsActive = attr.ib()  # type: bool\n\n    # Sequence settings of this job\n    SeqStart = attr.ib()  # type: int\n    SeqEnd = attr.ib()  # type: int\n    SeqStep = attr.ib()  # type: int\n    SeqFileOffset = attr.ib()  # type: int\n\n    # If you specify ImageDir, then ImageFilename has no path. If you do\n    # NOT specify ImageDir, then ImageFilename has to include the path.\n    # Same for ImageExtension.\n    # Important: Do not forget any _ or . in front or after the frame\n    # numbering. Usually ImageExtension always starts with a . (.tga, .exr)\n    ImageDir = attr.ib()  # type: str\n    ImageFilename = attr.ib()  # type: str\n    ImageExtension = attr.ib()  # type: str\n\n    # Some applications always add a . or _ in front of the frame number.\n    # Set this variable to that character. The user can then change\n    # the filename at the rrSubmitter and the submitter keeps\n    # track of this character.\n    ImagePreNumberLetter = attr.ib()  # type: str\n\n    # If you render a single file, e.g. Quicktime or Avi, then you have to\n    # set this value. Videos have to be rendered at once on one client.\n    ImageSingleOutputFile = attr.ib(default=False)  # type: bool\n\n    # Semi-Required (required for some render applications)\n    # -----------------------------------------------------\n\n    # The database of your scene file. In Maya and XSI called \"project\",\n    # in Lightwave \"content dir\"\n    SceneDatabaseDir = attr.ib(default=None)  # type: Optional[str]\n\n    # Required if you want to split frames on multiple clients\n    ImageWidth = attr.ib(default=None)  # type: Optional[int]\n    ImageHeight = attr.ib(default=None)  # type: Optional[int]\n    Camera = attr.ib(default=None)  # type: Optional[str]\n    Layer = attr.ib(default=None)  # type: Optional[str]\n    Channel = attr.ib(default=None)  # type: Optional[str]\n\n    # Optional\n    # --------\n\n    # Used for the RR render license function.\n    # E.g. If you render with mentalRay, then add mentalRay. If you render\n    # with Nuke and you use Furnace plugins in your comp, add Furnace.\n    # TODO: determine how this work for multiple plugins\n    RequiredPlugins = attr.ib(default=None)  # type: Optional[str]\n\n    # Frame Padding of the frame number in the rendered filename.\n    # Some render config files are setting the padding at render time.\n    ImageFramePadding = attr.ib(default=None)  # type: Optional[int]\n\n    # Some render applications support overriding the image format at\n    # the render commandline.\n    OverrideImageFormat = attr.ib(default=None)  # type: Optional[str]\n\n    # rrControl can display the name of additional channels that are\n    # rendered. Each channel requires these two values. ChannelFilename\n    # contains the full path.\n    ChannelFilename = attr.ib(default=None)  # type: Optional[str]\n    ChannelExtension = attr.ib(default=None)  # type: Optional[str]\n\n    # A value between 0 and 255. Each job gets the Pre ID attached as small\n    # letter to the main ID. A new main ID is generated for every machine\n    # for every 5/1000s.\n    PreID = attr.ib(default=None)  # type: Optional[int]\n\n    # When the job is received by the server, the server checks for other\n    # jobs send from this machine. If a job with the PreID was found, then\n    # this jobs waits for the other job. Note: This flag can be used multiple\n    # times to wait for multiple jobs.\n    WaitForPreIDs = attr.ib(factory=list)  # type: list\n\n    # List of submitter options per job\n    # list item must be of `SubmitterParameter` type\n    SubmitterParameters = attr.ib(factory=list)  # type: list\n\n    # List of Custom job attributes\n    # Royal Render support custom attributes in format &lt;CustomFoo&gt; or\n    # &lt;CustomSomeOtherAttr&gt;\n    # list item must be of `CustomAttribute` named tuple\n    CustomAttributes = attr.ib(factory=list)  # type: list\n\n    # This is used to hold command line arguments for Execute job\n    CustomAddCmdFlags = attr.ib(default=None)  # type: Optional[str]\n\n    # Additional information for subsequent publish script and\n    # for better display in rrControl\n    UserName = attr.ib(default=None)  # type: Optional[str]\n    CustomSeQName = attr.ib(default=None)  # type: Optional[str]\n    CustomSHotName = attr.ib(default=None)  # type: Optional[str]\n    CustomVersionName = attr.ib(default=None)  # type: Optional[str]\n    CustomUserInfo = attr.ib(default=None)  # type: Optional[str]\n    SubmitMachine = attr.ib(default=None)  # type: Optional[str]\n    Color_ID = attr.ib(default=2)  # type: int\n    CompanyProjectName = attr.ib(default=None)  # type: Optional[str]\n\n    RequiredLicenses = attr.ib(default=None)  # type: Optional[str]\n\n    # Additional frame info\n    Priority = attr.ib(default=50)  # type: int\n    TotalFrames = attr.ib(default=None)  # type: Optional[int]\n    Tiled = attr.ib(default=None)  # type: Optional[str]\n\n    # Environment\n    # only used in RR 8.3 and newer\n    rrEnvList = attr.ib(default=None, type=str)  # type: Optional[str]\n    rrEnvFile = attr.ib(default=None, type=str)  # type: Optional[str]\n\n    CustomScriptFile = attr.ib(default=None)  # type: Optional[str]\n</code></pre>"},{"location":"autoapi/client/ayon_royalrender/rr_job.html#client.ayon_royalrender.rr_job.SubmitFile","title":"<code>SubmitFile</code>","text":"<p>               Bases: <code>object</code></p> <p>Class wrapping Royal Render submission XML file.</p> Source code in <code>client/ayon_royalrender/rr_job.py</code> <pre><code>@attr.s\nclass SubmitFile(object):\n    \"\"\"Class wrapping Royal Render submission XML file.\"\"\"\n\n    # Syntax version of the submission file.\n    syntax_version = attr.ib(default=\"6.0\")  # type: str\n\n    # Delete submission file after processing\n    DeleteXML = attr.ib(default=1)  # type: int\n\n    # List of the submitter options per job.\n    # list item must be of `SubmitterParameter` type\n    SubmitterParameters = attr.ib(factory=list)  # type: list\n\n    # List of the jobs in submission batch.\n    # list item must be of type `RRJob`\n    Jobs = attr.ib(factory=list)  # type: list\n\n    @staticmethod\n    def _process_submitter_parameters(parameters, dom, append_to):\n        # type: (list[SubmitterParameter], md.Document, md.Element) -&gt; None\n        \"\"\"Take list of :class:`SubmitterParameter` and process it as XML.\n\n        This will take :class:`SubmitterParameter`, create XML element\n        for them and convert value to Royal Render compatible string\n        (options and values separated by ~)\n\n        Args:\n            parameters (list of SubmitterParameter): List of parameters.\n            dom (xml.dom.minidom.Document): XML Document\n            append_to (xml.dom.minidom.Element): Element to append to.\n\n        \"\"\"\n        for param in parameters:\n            if not isinstance(param, SubmitterParameter):\n                raise AttributeError(\n                    \"{} is not of type `SubmitterParameter`\".format(param))\n            xml_parameter = dom.createElement(\"SubmitterParameter\")\n            xml_parameter.appendChild(dom.createTextNode(param.serialize()))\n            append_to.appendChild(xml_parameter)\n\n    def serialize(self):\n        # type: () -&gt; str\n        \"\"\"Return all data serialized as XML.\n\n        Returns:\n            str: XML data as string.\n\n        \"\"\"\n        def filter_data(a, v):\n            \"\"\"Skip private attributes.\"\"\"\n            if a.name.startswith(\"_\"):\n                return False\n            if v is None:\n                return False\n            return True\n\n        root = md.Document()\n        # root element: &lt;RR_Job_File syntax_version=\"6.0\"&gt;\n        job_file = root.createElement('RR_Job_File')\n        job_file.setAttribute(\"syntax_version\", self.syntax_version)\n\n        # handle Submitter Parameters for batch\n        # &lt;SubmitterParameter&gt;foo=bar~baz~goo&lt;/SubmitterParameter&gt;\n        self._process_submitter_parameters(\n            self.SubmitterParameters, root, job_file)\n        root.appendChild(job_file)\n        for job in self.Jobs:  # type: RRJob\n            if not isinstance(job, RRJob):\n                raise AttributeError(\n                    \"{} is not of type `SubmitterParameter`\".format(job))\n            xml_job = root.createElement(\"Job\")\n            # handle Submitter Parameters for job\n            self._process_submitter_parameters(\n                job.SubmitterParameters, root, xml_job\n            )\n            job_custom_attributes = job.CustomAttributes\n\n            serialized_job = attr.asdict(\n                job, dict_factory=OrderedDict, filter=filter_data)\n            serialized_job.pop(\"CustomAttributes\")\n            serialized_job.pop(\"SubmitterParameters\")\n            # we are handling `WaitForPreIDs` separately.\n            wait_pre_ids = serialized_job.pop(\"WaitForPreIDs\", [])\n\n            for custom_attr in job_custom_attributes:  # type: CustomAttribute\n                serialized_job[\"Custom{}\".format(\n                    custom_attr.name)] = custom_attr.value\n\n            for item, value in serialized_job.items():\n                xml_attr = root.createElement(item)\n                xml_attr.appendChild(\n                    root.createTextNode(str(value))\n                )\n                xml_job.appendChild(xml_attr)\n\n            # WaitForPreID - can be used multiple times\n            for pre_id in wait_pre_ids:\n                xml_attr = root.createElement(\"WaitForPreID\")\n                xml_attr.appendChild(\n                    root.createTextNode(str(pre_id))\n                )\n                xml_job.appendChild(xml_attr)\n\n            job_file.appendChild(xml_job)\n\n        return root.toprettyxml(indent=\"\\t\")\n</code></pre>"},{"location":"autoapi/client/ayon_royalrender/rr_job.html#client.ayon_royalrender.rr_job.SubmitFile.serialize","title":"<code>serialize()</code>","text":"<p>Return all data serialized as XML.</p> <p>Returns:</p> Name Type Description <code>str</code> <p>XML data as string.</p> Source code in <code>client/ayon_royalrender/rr_job.py</code> <pre><code>def serialize(self):\n    # type: () -&gt; str\n    \"\"\"Return all data serialized as XML.\n\n    Returns:\n        str: XML data as string.\n\n    \"\"\"\n    def filter_data(a, v):\n        \"\"\"Skip private attributes.\"\"\"\n        if a.name.startswith(\"_\"):\n            return False\n        if v is None:\n            return False\n        return True\n\n    root = md.Document()\n    # root element: &lt;RR_Job_File syntax_version=\"6.0\"&gt;\n    job_file = root.createElement('RR_Job_File')\n    job_file.setAttribute(\"syntax_version\", self.syntax_version)\n\n    # handle Submitter Parameters for batch\n    # &lt;SubmitterParameter&gt;foo=bar~baz~goo&lt;/SubmitterParameter&gt;\n    self._process_submitter_parameters(\n        self.SubmitterParameters, root, job_file)\n    root.appendChild(job_file)\n    for job in self.Jobs:  # type: RRJob\n        if not isinstance(job, RRJob):\n            raise AttributeError(\n                \"{} is not of type `SubmitterParameter`\".format(job))\n        xml_job = root.createElement(\"Job\")\n        # handle Submitter Parameters for job\n        self._process_submitter_parameters(\n            job.SubmitterParameters, root, xml_job\n        )\n        job_custom_attributes = job.CustomAttributes\n\n        serialized_job = attr.asdict(\n            job, dict_factory=OrderedDict, filter=filter_data)\n        serialized_job.pop(\"CustomAttributes\")\n        serialized_job.pop(\"SubmitterParameters\")\n        # we are handling `WaitForPreIDs` separately.\n        wait_pre_ids = serialized_job.pop(\"WaitForPreIDs\", [])\n\n        for custom_attr in job_custom_attributes:  # type: CustomAttribute\n            serialized_job[\"Custom{}\".format(\n                custom_attr.name)] = custom_attr.value\n\n        for item, value in serialized_job.items():\n            xml_attr = root.createElement(item)\n            xml_attr.appendChild(\n                root.createTextNode(str(value))\n            )\n            xml_job.appendChild(xml_attr)\n\n        # WaitForPreID - can be used multiple times\n        for pre_id in wait_pre_ids:\n            xml_attr = root.createElement(\"WaitForPreID\")\n            xml_attr.appendChild(\n                root.createTextNode(str(pre_id))\n            )\n            xml_job.appendChild(xml_attr)\n\n        job_file.appendChild(xml_job)\n\n    return root.toprettyxml(indent=\"\\t\")\n</code></pre>"},{"location":"autoapi/client/ayon_royalrender/rr_job.html#client.ayon_royalrender.rr_job.SubmitterParameter","title":"<code>SubmitterParameter</code>","text":"<p>Wrapper for Submitter Parameters.</p> Source code in <code>client/ayon_royalrender/rr_job.py</code> <pre><code>class SubmitterParameter:\n    \"\"\"Wrapper for Submitter Parameters.\"\"\"\n    def __init__(self, parameter, *args):\n        # type: (str, list) -&gt; None\n        self._parameter = parameter\n        self._values = args\n\n    def serialize(self):\n        # type: () -&gt; str\n        \"\"\"Serialize submitter parameter as a string value.\n\n        This can be later on used as text node in job xml file.\n\n        Returns:\n            str: concatenated string of parameter values.\n\n        \"\"\"\n        if len(self._values) &gt; 0:\n            return \"{param}={val}\".format(\n                param=self._parameter, val=\"~\".join(self._values))\n\n        return \"{param}\".format(\n                param=self._parameter)\n</code></pre>"},{"location":"autoapi/client/ayon_royalrender/rr_job.html#client.ayon_royalrender.rr_job.SubmitterParameter.serialize","title":"<code>serialize()</code>","text":"<p>Serialize submitter parameter as a string value.</p> <p>This can be later on used as text node in job xml file.</p> <p>Returns:</p> Name Type Description <code>str</code> <p>concatenated string of parameter values.</p> Source code in <code>client/ayon_royalrender/rr_job.py</code> <pre><code>def serialize(self):\n    # type: () -&gt; str\n    \"\"\"Serialize submitter parameter as a string value.\n\n    This can be later on used as text node in job xml file.\n\n    Returns:\n        str: concatenated string of parameter values.\n\n    \"\"\"\n    if len(self._values) &gt; 0:\n        return \"{param}={val}\".format(\n            param=self._parameter, val=\"~\".join(self._values))\n\n    return \"{param}\".format(\n            param=self._parameter)\n</code></pre>"},{"location":"autoapi/client/ayon_royalrender/rr_job.html#client.ayon_royalrender.rr_job.get_rr_platform","title":"<code>get_rr_platform()</code>","text":"<p>Returns name of platform used in rr jobs.</p> Source code in <code>client/ayon_royalrender/rr_job.py</code> <pre><code>def get_rr_platform():\n    # type: () -&gt; Literal[\"windows\", \"linux\", \"osx\"]\n    \"\"\"Returns name of platform used in rr jobs.\"\"\"\n    if sys.platform.lower() in [\"win32\", \"win64\"]:\n        return \"windows\"\n    elif sys.platform.lower() == \"darwin\":\n        return \"osx\"\n    else:\n        return \"linux\"\n</code></pre>"},{"location":"autoapi/client/ayon_royalrender/version.html","title":"version","text":"<p>Package declaring AYON addon 'royalrender' version.</p>"},{"location":"autoapi/client/ayon_royalrender/plugins/index.html","title":"plugins","text":""},{"location":"autoapi/client/ayon_royalrender/plugins/publish/index.html","title":"publish","text":""},{"location":"autoapi/client/ayon_royalrender/plugins/publish/collect_royalrender_job_nev_vars.html","title":"collect_royalrender_job_nev_vars","text":""},{"location":"autoapi/client/ayon_royalrender/plugins/publish/collect_royalrender_job_nev_vars.html#client.ayon_royalrender.plugins.publish.collect_royalrender_job_nev_vars.CollectRoyalRenderJobEnvVars","title":"<code>CollectRoyalRenderJobEnvVars</code>","text":"<p>               Bases: <code>ContextPlugin</code></p> <p>Collect set of environment variables to submit with RR jobs</p> Source code in <code>client/ayon_royalrender/plugins/publish/collect_royalrender_job_nev_vars.py</code> <pre><code>class CollectRoyalRenderJobEnvVars(pyblish.api.ContextPlugin):\n    \"\"\"Collect set of environment variables to submit with RR jobs\"\"\"\n    order = pyblish.api.CollectorOrder\n    label = \"RoyalRender Farm Environment Variables\"\n    targets = [\"local\"]\n\n    ENV_KEYS = [\n        # applications addon\n        \"AYON_APP_NAME\",\n\n        # Not sure how this is usefull for farm, scared to remove\n        \"PYBLISHPLUGINPATH\",\n    ]\n\n    def process(self, context):\n        env = context.data.setdefault(FARM_JOB_ENV_DATA_KEY, {})\n        for key in self.ENV_KEYS:\n            # Skip already set keys\n            if key in env:\n                continue\n            value = os.getenv(key)\n            if value:\n                self.log.debug(f\"Setting job env: {key}: {value}\")\n                env[key] = value\n\n        if os.environ.get(\"AYON_USE_STAGING\"):\n            env[\"AYON_USE_STAGING\"] = \"1\"\n</code></pre>"},{"location":"autoapi/client/ayon_royalrender/plugins/publish/collect_rr_path_from_instance.html","title":"collect_rr_path_from_instance","text":"Requires <p>instance.context.data[\"project_settings\"]</p> <p>Provides:     instance.data[\"rr_root\"] (str) - root folder of RoyalRender server</p>"},{"location":"autoapi/client/ayon_royalrender/plugins/publish/collect_rr_path_from_instance.html#client.ayon_royalrender.plugins.publish.collect_rr_path_from_instance.CollectRRPathFromInstance","title":"<code>CollectRRPathFromInstance</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Collect RR Path from instance.</p> <p>All RoyalRender server roots are set in <code>Studio Settings</code>, each project uses only key pointing to that part to limit typos inside of Project settings. Eventually could be possible to add dropdown with these keys to the Creators to allow artists to select which RR server they would like to use.</p> Source code in <code>client/ayon_royalrender/plugins/publish/collect_rr_path_from_instance.py</code> <pre><code>class CollectRRPathFromInstance(pyblish.api.InstancePlugin):\n    \"\"\"Collect RR Path from instance.\n\n    All RoyalRender server roots are set in `Studio Settings`, each project\n    uses only key pointing to that part to limit typos inside of Project\n    settings.\n    Eventually could be possible to add dropdown with these keys to the\n    Creators to allow artists to select which RR server they would like to use.\n    \"\"\"\n\n    order = pyblish.api.CollectorOrder\n    label = \"Collect Royal Render path name from the Instance\"\n    families = [\"render\", \"prerender\", \"renderlayer\", \"pointcache\"]\n\n    def process(self, instance):\n        instance.data[\"rr_root\"] = self._collect_root(instance)\n        self.log.info(\n            \"Using '{}' for submission.\".format(instance.data[\"rr_root\"]))\n\n    def _collect_root(self, instance):\n        # type: (pyblish.api.Instance) -&gt; str\n        \"\"\"Get Royal Render path name from render instance.\n        If artist should be able to select specific RR server it must be added\n        to creator. It is not there yet.\n        \"\"\"\n        rr_settings = instance.context.data[\"project_settings\"][\"royalrender\"]\n        rr_paths = rr_settings[\"rr_paths\"]\n        selected_keys = rr_settings[\"selected_rr_paths\"]\n\n        platform = get_rr_platform()\n        key_to_path = {\n            item[\"name\"]: item[\"value\"][platform]\n            for item in rr_paths\n        }\n\n        for selected_key in selected_keys:\n            rr_root = key_to_path[selected_key]\n            if os.path.exists(rr_root):\n                return rr_root\n</code></pre>"},{"location":"autoapi/client/ayon_royalrender/plugins/publish/collect_sequences_from_job.html","title":"collect_sequences_from_job","text":"<p>Collect sequences from Royal Render Job.</p>"},{"location":"autoapi/client/ayon_royalrender/plugins/publish/collect_sequences_from_job.html#client.ayon_royalrender.plugins.publish.collect_sequences_from_job.CollectSequencesFromJob","title":"<code>CollectSequencesFromJob</code>","text":"<p>               Bases: <code>ContextPlugin</code></p> <p>Gather file sequences from job directory.</p> <p>When \"AYON_PUBLISH_DATA\" environment variable is set these paths (folders or .json files) are parsed for image sequences. Otherwise, the current working directory is searched for file sequences.</p> Source code in <code>client/ayon_royalrender/plugins/publish/collect_sequences_from_job.py</code> <pre><code>class CollectSequencesFromJob(pyblish.api.ContextPlugin):\n    \"\"\"Gather file sequences from job directory.\n\n    When \"AYON_PUBLISH_DATA\" environment variable is set these paths\n    (folders or .json files) are parsed for image sequences. Otherwise, the\n    current working directory is searched for file sequences.\n\n    \"\"\"\n\n    order = pyblish.api.CollectorOrder\n    targets = [\"rr_control\"]\n    label = \"Collect Rendered Frames\"\n    settings_category = \"royalrender\"\n    review = True\n\n    def process(self, context):\n        self.review = context.data[\"project_settings\"][\"royalrender\"][\n            \"publish\"\n        ][\"CollectSequencesFromJob\"][\"review\"]\n\n        self.review = (\n            context.data\n            [\"project_settings\"]\n            [\"royalrender\"]\n            [\"publish\"]\n            [\"CollectSequencesFromJob\"]\n            [\"review\"]\n        )\n\n        publish_data_paths = os.environ.get(\"AYON_PUBLISH_DATA\")\n\n        if publish_data_paths:\n            self.log.debug(publish_data_paths)\n            paths = publish_data_paths.split(os.pathsep)\n            self.log.info(\"Collecting paths: {}\".format(paths))\n        else:\n            cwd = context.get(\"workspaceDir\", os.getcwd())\n            paths = [cwd]\n\n        for path in paths:\n\n            self.log.info(\"Loading: {}\".format(path))\n\n            if path.endswith(\".json\"):\n                # Search using .json configuration\n                with open(path, \"r\") as f:\n                    try:\n                        data = json.load(f)\n                    except Exception as exc:\n                        self.log.error(\"Error loading json: \"\n                                       \"{} - Exception: {}\".format(path, exc))\n                        raise\n\n                cwd = os.path.dirname(path)\n                root_override = data.get(\"root\")\n                if root_override:\n                    if os.path.isabs(root_override):\n                        root = root_override\n                    else:\n                        root = os.path.join(cwd, root_override)\n                else:\n                    root = cwd\n\n                metadata = data.get(\"metadata\")\n                if metadata:\n                    session = metadata.get(\"session\")\n                    if session:\n                        self.log.info(\"setting session using metadata\")\n                        os.environ.update(session)\n\n            else:\n                # Search in directory\n                data = {}\n                root = path\n\n            self.log.info(\"Collecting: {}\".format(root))\n            regex = data.get(\"regex\")\n            if regex:\n                self.log.info(\"Using regex: {}\".format(regex))\n\n            collections = collect(root=root,\n                                  regex=regex,\n                                  exclude_regex=data.get(\"exclude_regex\"),\n                                  frame_start=data.get(\"frameStart\"),\n                                  frame_end=data.get(\"frameEnd\"))\n\n            self.log.info(\"Found collections: {}\".format(collections))\n\n            if data.get(\"productName\") and len(collections) &gt; 1:\n                self.log.error(\"Forced produce can only work with a single \"\n                               \"found sequence\")\n                raise RuntimeError(\"Invalid sequence\")\n\n            fps = data.get(\"fps\", 25)\n\n            # Get family from the data\n            families = data.get(\"families\", [\"render\"])\n            if \"render\" not in families:\n                families.append(\"render\")\n            if \"ftrack\" not in families:\n                families.append(\"ftrack\")\n            if \"review\" not in families and self.review:\n                self.log.info(\"attaching review\")\n                families.append(\"review\")\n\n            product_base_type = families[0]\n            for collection in collections:\n                instance = context.create_instance(str(collection))\n                self.log.info(\"Collection: %s\" % list(collection))\n\n                # Ensure each instance gets a unique reference to the data\n                data = copy.deepcopy(data)\n\n                # If no product provided, get it from collection's head\n                product_name = (\n                    data.get(\"productName\", collection.head.rstrip(\"_. \"))\n                )\n\n                # If no start or end frame provided, get it from collection\n                indices = list(collection.indexes)\n                start = data.get(\"frameStart\", indices[0])\n                end = data.get(\"frameEnd\", indices[-1])\n\n                ext = list(collection)[0].split('.')[-1]\n\n                instance.data.update({\n                    \"name\": str(collection),\n                    \"productType\": product_base_type,\n                    \"productBaseType\": product_base_type,\n                    \"family\": product_base_type,\n                    \"families\": list(families),\n                    \"productName\": product_name,\n                    \"folderPath\": data.get(\n                        \"folderPath\", context.data[\"folderPath\"]\n                    ),\n                    \"stagingDir\": root,\n                    \"frameStart\": start,\n                    \"frameEnd\": end,\n                    \"fps\": fps,\n                    \"source\": data.get('source', '')\n                })\n                instance.append(collection)\n                instance.context.data['fps'] = fps\n\n                if \"representations\" not in instance.data:\n                    instance.data[\"representations\"] = []\n\n                representation = {\n                    'name': ext,\n                    'ext': '{}'.format(ext),\n                    'files': list(collection),\n                    \"frameStart\": start,\n                    \"frameEnd\": end,\n                    \"stagingDir\": root,\n                    \"anatomy_template\": \"render\",\n                    \"fps\": fps,\n                    \"tags\": ['review']\n                }\n                instance.data[\"representations\"].append(representation)\n\n                if data.get('user'):\n                    context.data[\"user\"] = data['user']\n\n                self.log.debug(\"Collected instance:\\n\"\n                               \"{}\".format(pformat(instance.data)))\n</code></pre>"},{"location":"autoapi/client/ayon_royalrender/plugins/publish/collect_sequences_from_job.html#client.ayon_royalrender.plugins.publish.collect_sequences_from_job.collect","title":"<code>collect(root, regex=None, exclude_regex=None, frame_start=None, frame_end=None)</code>","text":"<p>Collect sequence collections in root</p> Source code in <code>client/ayon_royalrender/plugins/publish/collect_sequences_from_job.py</code> <pre><code>def collect(root,\n            regex=None,\n            exclude_regex=None,\n            frame_start=None,\n            frame_end=None):\n    \"\"\"Collect sequence collections in root\"\"\"\n\n    import clique\n\n    files = []\n    for filename in os.listdir(root):\n\n        # Must have extension\n        ext = os.path.splitext(filename)[1]\n        if not ext:\n            continue\n\n        # Only files\n        if not os.path.isfile(os.path.join(root, filename)):\n            continue\n\n        # Include and exclude regex\n        if regex and not re.search(regex, filename):\n            continue\n        if exclude_regex and re.search(exclude_regex, filename):\n            continue\n\n        files.append(filename)\n\n    # Match collections\n    # Support filenames like: projectX_shot01_0010.tiff with this regex\n    pattern = r\"(?P&lt;index&gt;(?P&lt;padding&gt;0*)\\d+)\\.\\D+\\d?$\"\n    collections, remainder = clique.assemble(files,\n                                             patterns=[pattern],\n                                             minimum_items=1)\n\n    # Ignore any remainders\n    if remainder:\n        print(\"Skipping remainder {}\".format(remainder))\n\n    # Exclude any frames outside start and end frame.\n    for collection in collections:\n        for index in list(collection.indexes):\n            if frame_start is not None and index &lt; frame_start:\n                collection.indexes.discard(index)\n                continue\n            if frame_end is not None and index &gt; frame_end:\n                collection.indexes.discard(index)\n                continue\n\n    # Keep only collections that have at least a single frame\n    collections = [c for c in collections if c.indexes]\n\n    return collections\n</code></pre>"},{"location":"autoapi/client/ayon_royalrender/plugins/publish/create_maya_cache_royalrender_job.html","title":"create_maya_cache_royalrender_job","text":"<p>Submitting render job to RoyalRender.</p>"},{"location":"autoapi/client/ayon_royalrender/plugins/publish/create_maya_cache_royalrender_job.html#client.ayon_royalrender.plugins.publish.create_maya_cache_royalrender_job.CreateMayaCacheRoyalRenderJob","title":"<code>CreateMayaCacheRoyalRenderJob</code>","text":"<p>               Bases: <code>BaseCreateRoyalRenderJob</code></p> Source code in <code>client/ayon_royalrender/plugins/publish/create_maya_cache_royalrender_job.py</code> <pre><code>class CreateMayaCacheRoyalRenderJob(lib.BaseCreateRoyalRenderJob):\n    label = \"Create Maya Cache job in RR\"\n    hosts = [\"maya\"]\n    families = [\"pointcache\"]\n    targets = [\"local\"]\n\n    def update_job_with_host_specific(self, instance, job):\n        job.Software = \"Maya\"\n        job.Renderer = \"RemotePublish\"\n        job.Version = \"{0:.2f}\".format(MGlobal.apiVersion() / 10000)\n        job.CustomScriptFile = \"&lt;rrLocalRenderScripts&gt;/ayon_remote_publish.py\"\n        workspace = instance.context.data[\"workspaceDir\"]\n        job.SceneDatabaseDir = workspace\n        job.rrEnvList += f\"~~~INSTANCE_IDS={instance.data['instance_id']}\"\n\n        return job\n\n    def process(self, instance):\n        \"\"\"Plugin entry point.\"\"\"\n        if not instance.data.get(\"farm\"):\n            self.log.info(\"Skipping local instance.\")\n            return\n\n        super().process(instance)\n\n        # append full path\n        renders_dir = os.path.join(\n           cmds.workspace(query=True, rootDirectory=True),\n           cmds.workspace(fileRuleEntry=\"images\")\n        )\n\n        job = self.get_job(\n            instance,\n            self.scene_path,\n            renders_dir,\n            \"\",\n            job_type=\"REMOTE\"\n        )\n        job = self.update_job_with_host_specific(instance, job)\n\n        instance.data[\"rrJobs\"].append(job)\n</code></pre>"},{"location":"autoapi/client/ayon_royalrender/plugins/publish/create_maya_cache_royalrender_job.html#client.ayon_royalrender.plugins.publish.create_maya_cache_royalrender_job.CreateMayaCacheRoyalRenderJob.process","title":"<code>process(instance)</code>","text":"<p>Plugin entry point.</p> Source code in <code>client/ayon_royalrender/plugins/publish/create_maya_cache_royalrender_job.py</code> <pre><code>def process(self, instance):\n    \"\"\"Plugin entry point.\"\"\"\n    if not instance.data.get(\"farm\"):\n        self.log.info(\"Skipping local instance.\")\n        return\n\n    super().process(instance)\n\n    # append full path\n    renders_dir = os.path.join(\n       cmds.workspace(query=True, rootDirectory=True),\n       cmds.workspace(fileRuleEntry=\"images\")\n    )\n\n    job = self.get_job(\n        instance,\n        self.scene_path,\n        renders_dir,\n        \"\",\n        job_type=\"REMOTE\"\n    )\n    job = self.update_job_with_host_specific(instance, job)\n\n    instance.data[\"rrJobs\"].append(job)\n</code></pre>"},{"location":"autoapi/client/ayon_royalrender/plugins/publish/create_maya_royalrender_job.html","title":"create_maya_royalrender_job","text":"<p>Submitting render job to RoyalRender.</p>"},{"location":"autoapi/client/ayon_royalrender/plugins/publish/create_maya_royalrender_job.html#client.ayon_royalrender.plugins.publish.create_maya_royalrender_job.CreateMayaRoyalRenderJob","title":"<code>CreateMayaRoyalRenderJob</code>","text":"<p>               Bases: <code>BaseCreateRoyalRenderJob</code></p> Source code in <code>client/ayon_royalrender/plugins/publish/create_maya_royalrender_job.py</code> <pre><code>class CreateMayaRoyalRenderJob(lib.BaseCreateRoyalRenderJob):\n    label = \"Create Maya Render job in RR\"\n    hosts = [\"maya\"]\n    families = [\"renderlayer\"]\n    targets = [\"local\"]\n\n    def update_job_with_host_specific(self, instance, job):\n        job.Software = \"Maya\"\n        job.Renderer = \"arnold-maya\"\n        job.Version = \"{0:.2f}\".format(MGlobal.apiVersion() / 10000)\n        if instance.data.get(\"cameras\"):\n            job.Camera = instance.data[\"cameras\"][0].replace(\"'\", '\"')\n        workspace = instance.context.data[\"workspaceDir\"]\n        job.SceneDatabaseDir = workspace\n\n        return job\n\n    def process(self, instance):\n        \"\"\"Plugin entry point.\"\"\"\n        super(CreateMayaRoyalRenderJob, self).process(instance)\n\n        expected_files = instance.data[\"expectedFiles\"]\n        first_file_path = next(iter_expected_files(expected_files))\n        output_dir = os.path.dirname(first_file_path)\n        instance.data[\"outputDir\"] = output_dir\n\n        layer = instance.data[\"setMembers\"]  # type: str\n        layer_name = layer.removeprefix(\"rs_\")\n\n        job = self.get_job(\n            instance, self.scene_path, first_file_path, layer_name\n        )\n        job = self.update_job_with_host_specific(instance, job)\n\n        instance.data[\"rrJobs\"].append(job)\n</code></pre>"},{"location":"autoapi/client/ayon_royalrender/plugins/publish/create_maya_royalrender_job.html#client.ayon_royalrender.plugins.publish.create_maya_royalrender_job.CreateMayaRoyalRenderJob.process","title":"<code>process(instance)</code>","text":"<p>Plugin entry point.</p> Source code in <code>client/ayon_royalrender/plugins/publish/create_maya_royalrender_job.py</code> <pre><code>def process(self, instance):\n    \"\"\"Plugin entry point.\"\"\"\n    super(CreateMayaRoyalRenderJob, self).process(instance)\n\n    expected_files = instance.data[\"expectedFiles\"]\n    first_file_path = next(iter_expected_files(expected_files))\n    output_dir = os.path.dirname(first_file_path)\n    instance.data[\"outputDir\"] = output_dir\n\n    layer = instance.data[\"setMembers\"]  # type: str\n    layer_name = layer.removeprefix(\"rs_\")\n\n    job = self.get_job(\n        instance, self.scene_path, first_file_path, layer_name\n    )\n    job = self.update_job_with_host_specific(instance, job)\n\n    instance.data[\"rrJobs\"].append(job)\n</code></pre>"},{"location":"autoapi/client/ayon_royalrender/plugins/publish/create_nuke_royalrender_job.html","title":"create_nuke_royalrender_job","text":"<p>Submitting render job to RoyalRender.</p>"},{"location":"autoapi/client/ayon_royalrender/plugins/publish/create_nuke_royalrender_job.html#client.ayon_royalrender.plugins.publish.create_nuke_royalrender_job.CreateNukeRoyalRenderJob","title":"<code>CreateNukeRoyalRenderJob</code>","text":"<p>               Bases: <code>BaseCreateRoyalRenderJob</code></p> <p>Creates separate rendering job for Royal Render</p> Source code in <code>client/ayon_royalrender/plugins/publish/create_nuke_royalrender_job.py</code> <pre><code>class CreateNukeRoyalRenderJob(lib.BaseCreateRoyalRenderJob):\n    \"\"\"Creates separate rendering job for Royal Render\"\"\"\n\n    label = \"Create Nuke Render job in RR\"\n    hosts = [\"nuke\"]\n    families = [\"render\", \"prerender\"]\n    targets = [\"local\"]\n\n    def process(self, instance):\n        super(CreateNukeRoyalRenderJob, self).process(instance)\n        # allow skip to\n        if not instance.data.get(\"farm\"):\n            self.log.info(\"Skipping local instance.\")\n            return\n        # redefinition of families\n        product_base_type = instance.data.get(\"productBaseType\")\n        if not product_base_type:\n            product_base_type = instance.data[\"productType\"]\n        if \"render\" in product_base_type:\n            instance.data[\"productType\"] = \"write\"\n            instance.data[\"productBaseType\"] = \"write\"\n            instance.data[\"family\"] = \"write\"\n            instance.data[\"families\"].insert(0, \"render2d\")\n        elif \"prerender\" in product_base_type:\n            instance.data[\"productType\"] = \"write\"\n            instance.data[\"productBaseType\"] = \"write\"\n            instance.data[\"family\"] = \"write\"\n            instance.data[\"families\"].insert(0, \"prerender\")\n\n        jobs = self.create_jobs(instance)\n        for job in jobs:\n            job = self.update_job_with_host_specific(instance, job)\n            instance.data[\"rrJobs\"].append(job)\n\n    def update_job_with_host_specific(self, instance, job):\n        # INFECTED Nuke Version\n        nuke_version = instance.context.data.get(\"hostVersion\")\n        job.Software = \"Nuke\"\n        job.Version = nuke_version\n\n        return job\n\n    def create_jobs(self, instance):\n        \"\"\"Nuke creates multiple RR jobs - for baking etc.\"\"\"\n        # get output path\n        render_path = instance.data[\"path\"]\n        script_path = self.scene_path\n        node = instance.data[\"transientData\"][\"node\"]\n\n        # main job\n        jobs = [self.get_job(instance, script_path, render_path, node.name())]\n\n        for baking_script in instance.data.get(\"bakingNukeScripts\", []):\n            render_path = baking_script[\"bakeRenderPath\"]\n            script_path = baking_script[\"bakeScriptPath\"]\n            exe_node_name = baking_script[\"bakeWriteNodeName\"]\n            single = True\n            jobs.append(\n                self.get_job(\n                    instance, script_path, render_path, exe_node_name, single\n                )\n            )\n\n        return jobs\n</code></pre>"},{"location":"autoapi/client/ayon_royalrender/plugins/publish/create_nuke_royalrender_job.html#client.ayon_royalrender.plugins.publish.create_nuke_royalrender_job.CreateNukeRoyalRenderJob.create_jobs","title":"<code>create_jobs(instance)</code>","text":"<p>Nuke creates multiple RR jobs - for baking etc.</p> Source code in <code>client/ayon_royalrender/plugins/publish/create_nuke_royalrender_job.py</code> <pre><code>def create_jobs(self, instance):\n    \"\"\"Nuke creates multiple RR jobs - for baking etc.\"\"\"\n    # get output path\n    render_path = instance.data[\"path\"]\n    script_path = self.scene_path\n    node = instance.data[\"transientData\"][\"node\"]\n\n    # main job\n    jobs = [self.get_job(instance, script_path, render_path, node.name())]\n\n    for baking_script in instance.data.get(\"bakingNukeScripts\", []):\n        render_path = baking_script[\"bakeRenderPath\"]\n        script_path = baking_script[\"bakeScriptPath\"]\n        exe_node_name = baking_script[\"bakeWriteNodeName\"]\n        single = True\n        jobs.append(\n            self.get_job(\n                instance, script_path, render_path, exe_node_name, single\n            )\n        )\n\n    return jobs\n</code></pre>"},{"location":"autoapi/client/ayon_royalrender/plugins/publish/create_publish_royalrender_job.html","title":"create_publish_royalrender_job","text":"<p>Create publishing job on RoyalRender.</p>"},{"location":"autoapi/client/ayon_royalrender/plugins/publish/create_publish_royalrender_job.html#client.ayon_royalrender.plugins.publish.create_publish_royalrender_job.CreatePublishRoyalRenderJob","title":"<code>CreatePublishRoyalRenderJob</code>","text":"<p>               Bases: <code>InstancePlugin</code>, <code>ColormanagedPyblishPluginMixin</code></p> <p>Creates job which publishes rendered files to publish area.</p> <p>Job waits until all rendering jobs are finished, triggers <code>publish</code> command where it reads from prepared .json file with metadata about what should be published, renames prepared images and publishes them.</p> <p>When triggered it produces .log file next to .json file in work area.</p> Source code in <code>client/ayon_royalrender/plugins/publish/create_publish_royalrender_job.py</code> <pre><code>class CreatePublishRoyalRenderJob(pyblish.api.InstancePlugin,\n                                  publish.ColormanagedPyblishPluginMixin):\n    \"\"\"Creates job which publishes rendered files to publish area.\n\n    Job waits until all rendering jobs are finished, triggers `publish` command\n    where it reads from prepared .json file with metadata about what should\n    be published, renames prepared images and publishes them.\n\n    When triggered it produces .log file next to .json file in work area.\n    \"\"\"\n    label = \"Create publish job in RR\"\n    order = pyblish.api.IntegratorOrder + 0.2\n    icon = \"tractor\"\n    targets = [\"local\"]\n    hosts = [\"fusion\", \"maya\", \"nuke\", \"celaction\", \"aftereffects\", \"harmony\"]\n    families = [\"render.farm\", \"prerender.farm\", \"render.frames_farm\",\n                \"renderlayer\", \"imagesequence\", \"vrayscene\"]\n    aov_filter = {\"maya\": [r\".*([Bb]eauty).*\"],\n                  \"aftereffects\": [r\".*\"],  # for everything from AE\n                  \"harmony\": [r\".*\"],  # for everything from AE\n                  \"celaction\": [r\".*\"]}\n\n    skip_integration_repre_list = []\n\n    # mapping of instance properties to be transferred to new instance\n    #     for every specified family\n    instance_transfer = {\n        \"slate\": [\"slateFrames\", \"slate\"],\n        \"review\": [\"lutPath\"],\n        \"render2d\": [\"bakingNukeScripts\", \"version\"],\n        \"renderlayer\": [\"convertToScanline\"]\n    }\n\n    # list of family names to transfer to new family if present\n    families_transfer = [\"render3d\", \"render2d\", \"ftrack\", \"slate\"]\n\n    priority = 50\n\n    def process(self, instance):\n        context = instance.context\n        self.context = context\n        self.anatomy = instance.context.data[\"anatomy\"]\n\n        if not instance.data.get(\"farm\") or instance.data.get(\"frames_farm\"):\n            self.log.info(\"Skipping local instance.\")\n            return\n\n        instance_skeleton_data = create_skeleton_instance(\n            instance,\n            families_transfer=self.families_transfer,\n            instance_transfer=self.instance_transfer)\n\n        do_not_add_review = False\n        if instance.data.get(\"review\") is False:\n            self.log.debug(\"Instance has review explicitly disabled.\")\n            do_not_add_review = True\n\n        if isinstance(instance.data.get(\"expectedFiles\")[0], dict):\n            instances = create_instances_for_aov(\n                instance, instance_skeleton_data,\n                self.aov_filter, self.skip_integration_repre_list,\n                do_not_add_review)\n\n        else:\n            representations = prepare_representations(\n                instance_skeleton_data,\n                instance.data.get(\"expectedFiles\"),\n                self.anatomy,\n                self.aov_filter,\n                self.skip_integration_repre_list,\n                do_not_add_review,\n                instance.context,\n                self\n            )\n\n            if \"representations\" not in instance_skeleton_data.keys():\n                instance_skeleton_data[\"representations\"] = []\n\n            # add representation\n            instance_skeleton_data[\"representations\"] += representations\n            instances = [instance_skeleton_data]\n\n        # attach instances to product\n        if instance.data.get(\"attachTo\"):\n            instances = attach_instances_to_product(\n                instance.data.get(\"attachTo\"), instances\n            )\n\n        self.log.info(\"Creating RoyalRender Publish job ...\")\n\n        if not instance.data.get(\"rrJobs\"):\n            self.log.error((\"There is no prior RoyalRender \"\n                            \"job on the instance.\"))\n            raise KnownPublishError(\n                \"Can't create publish job without prior rendering jobs first\")\n\n        rr_job = self.get_job(instance, instances)\n        instance.data[\"rrJobs\"].append(rr_job)\n\n        # publish job file\n        publish_job = {\n            \"folderPath\": instance_skeleton_data[\"folderPath\"],\n            \"frameStart\": instance_skeleton_data[\"frameStart\"],\n            \"frameEnd\": instance_skeleton_data[\"frameEnd\"],\n            \"fps\": instance_skeleton_data[\"fps\"],\n            \"source\": instance_skeleton_data[\"source\"],\n            \"user\": instance.context.data[\"user\"],\n            \"version\": instance.context.data[\"version\"],   # workfile version\n            \"intent\": instance.context.data.get(\"intent\"),\n            \"comment\": instance.context.data.get(\"comment\"),\n            \"job\": attr.asdict(rr_job),\n            \"instances\": instances\n        }\n\n        metadata_path, rootless_metadata_path = \\\n            create_metadata_path(instance, self.anatomy)\n\n        self.log.info(\"Writing json file: {}\".format(metadata_path))\n\n        #convert submitter parameters to str as preparation for\n        #json dump - needs improvement\n        publish_job[\"job\"][\"SubmitterParameters\"] = str(publish_job[\"job\"][\"SubmitterParameters\"])\n\n\n        with open(metadata_path, \"w\") as f:\n            json.dump(publish_job, f, indent=4, sort_keys=True)\n\n    def get_job(self, instance, instances):\n        \"\"\"Create RR publishing job.\n\n        Based on provided original instance and additional instances,\n        create publishing job and return it to be submitted to farm.\n\n        Args:\n            instance (Instance): Original instance.\n            instances (list of Instance): List of instances to\n                be published on farm.\n\n        Returns:\n            RRJob: RoyalRender publish job.\n\n        \"\"\"\n        data = instance.data.copy()\n        product_name = data[\"productName\"]\n        jobname = \"Publish - {}\".format(product_name)\n\n        environment = get_instance_job_envs(instance)\n        environment.update(JobType[\"PUBLISH\"].get_job_env())\n        environment = RREnvList(**environment)\n        environment_serialized = environment.serialize()\n\n        # pass environment keys from self.environ_job_filter\n        # and collect all pre_ids to wait for\n        job_environ = {}\n        jobs_pre_ids = []\n        for job in instance.data[\"rrJobs\"]:  # type: RRJob\n            if job.rrEnvList:\n                if len(job.rrEnvList) &gt; 2000:\n                    self.log.warning((\"Job environment is too long \"\n                                      f\"{len(job.rrEnvList)} &gt; 2000\"))\n                job_environ.update(\n                    dict(RREnvList.parse(job.rrEnvList))\n                )\n            jobs_pre_ids.append(job.PreID)\n\n        priority = self.priority or instance.data.get(\"priority\", 50)\n        suspend_publish = instance.data.get(\"suspend_publish\", False)\n\n        submitter_parameters_job = [\n            SubmitterParameter(\n                \"SendJobDisabled\",\n                \"1\",\n                str(suspend_publish)\n            ),\n            SubmitterParameter(\n                \"Priority\",\n                \"1\",\n                str(priority)\n            )\n        ]\n\n        # rr requires absolut path or all jobs won't show up in rControl\n        _, rootless_metadata_path = create_metadata_path(instance, self.anatomy)\n        abs_metadata_path = self.anatomy.fill_root(rootless_metadata_path)\n\n        # additional logging\n        args = [\n            \"&gt;\", os.path.join(os.path.dirname(abs_metadata_path),\n                              \"rr_out.log\"),\n            \"2&gt;&amp;1\"\n        ]\n\n        job = RRJob(\n            Software=\"AYON\",\n            Renderer=\"Once\",\n            SeqStart=1,\n            SeqEnd=1,\n            SeqStep=1,\n            SeqFileOffset=0,\n            # Pass the launcher executable version because Royal Render will\n            # use pattern matching to find the relevant executable if it's\n            # configured with a path like:\n            # `C:\\Program Files\\Ynput\\AYON *\\ayon_console.exe.`\n            # However we do recommend configuring pointing it to the shim\n            # location so the executable is a versionless path.\n            Version=os.environ[\"AYON_VERSION\"],\n            SceneName=abs_metadata_path,\n            # command line arguments\n            CustomAddCmdFlags=\" \".join(args),\n            IsActive=True,\n            ImageFilename=\"execOnce.file\",\n            ImageDir=\"&lt;SceneFolder&gt;\",\n            ImageExtension=\"\",\n            ImagePreNumberLetter=\"\",\n            SceneOS=get_rr_platform(),\n            rrEnvList=environment_serialized,\n            CustomSHotName=jobname,\n            CompanyProjectName=instance.context.data[\"projectName\"],\n            SubmitterParameters=submitter_parameters_job\n        )\n\n        # add assembly jobs as dependencies\n        if instance.data.get(\"tileRendering\"):\n            self.log.info(\"Adding tile assembly jobs as dependencies...\")\n            job.WaitForPreIDs += instance.data.get(\"assemblySubmissionJobs\")\n        elif instance.data.get(\"bakingSubmissionJobs\"):\n            self.log.info(\"Adding baking submission jobs as dependencies...\")\n            job.WaitForPreIDs += instance.data[\"bakingSubmissionJobs\"]\n        else:\n            job.WaitForPreIDs += jobs_pre_ids\n\n        return job\n</code></pre>"},{"location":"autoapi/client/ayon_royalrender/plugins/publish/create_publish_royalrender_job.html#client.ayon_royalrender.plugins.publish.create_publish_royalrender_job.CreatePublishRoyalRenderJob.get_job","title":"<code>get_job(instance, instances)</code>","text":"<p>Create RR publishing job.</p> <p>Based on provided original instance and additional instances, create publishing job and return it to be submitted to farm.</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>Instance</code> <p>Original instance.</p> required <code>instances</code> <code>list of Instance</code> <p>List of instances to be published on farm.</p> required <p>Returns:</p> Name Type Description <code>RRJob</code> <p>RoyalRender publish job.</p> Source code in <code>client/ayon_royalrender/plugins/publish/create_publish_royalrender_job.py</code> <pre><code>def get_job(self, instance, instances):\n    \"\"\"Create RR publishing job.\n\n    Based on provided original instance and additional instances,\n    create publishing job and return it to be submitted to farm.\n\n    Args:\n        instance (Instance): Original instance.\n        instances (list of Instance): List of instances to\n            be published on farm.\n\n    Returns:\n        RRJob: RoyalRender publish job.\n\n    \"\"\"\n    data = instance.data.copy()\n    product_name = data[\"productName\"]\n    jobname = \"Publish - {}\".format(product_name)\n\n    environment = get_instance_job_envs(instance)\n    environment.update(JobType[\"PUBLISH\"].get_job_env())\n    environment = RREnvList(**environment)\n    environment_serialized = environment.serialize()\n\n    # pass environment keys from self.environ_job_filter\n    # and collect all pre_ids to wait for\n    job_environ = {}\n    jobs_pre_ids = []\n    for job in instance.data[\"rrJobs\"]:  # type: RRJob\n        if job.rrEnvList:\n            if len(job.rrEnvList) &gt; 2000:\n                self.log.warning((\"Job environment is too long \"\n                                  f\"{len(job.rrEnvList)} &gt; 2000\"))\n            job_environ.update(\n                dict(RREnvList.parse(job.rrEnvList))\n            )\n        jobs_pre_ids.append(job.PreID)\n\n    priority = self.priority or instance.data.get(\"priority\", 50)\n    suspend_publish = instance.data.get(\"suspend_publish\", False)\n\n    submitter_parameters_job = [\n        SubmitterParameter(\n            \"SendJobDisabled\",\n            \"1\",\n            str(suspend_publish)\n        ),\n        SubmitterParameter(\n            \"Priority\",\n            \"1\",\n            str(priority)\n        )\n    ]\n\n    # rr requires absolut path or all jobs won't show up in rControl\n    _, rootless_metadata_path = create_metadata_path(instance, self.anatomy)\n    abs_metadata_path = self.anatomy.fill_root(rootless_metadata_path)\n\n    # additional logging\n    args = [\n        \"&gt;\", os.path.join(os.path.dirname(abs_metadata_path),\n                          \"rr_out.log\"),\n        \"2&gt;&amp;1\"\n    ]\n\n    job = RRJob(\n        Software=\"AYON\",\n        Renderer=\"Once\",\n        SeqStart=1,\n        SeqEnd=1,\n        SeqStep=1,\n        SeqFileOffset=0,\n        # Pass the launcher executable version because Royal Render will\n        # use pattern matching to find the relevant executable if it's\n        # configured with a path like:\n        # `C:\\Program Files\\Ynput\\AYON *\\ayon_console.exe.`\n        # However we do recommend configuring pointing it to the shim\n        # location so the executable is a versionless path.\n        Version=os.environ[\"AYON_VERSION\"],\n        SceneName=abs_metadata_path,\n        # command line arguments\n        CustomAddCmdFlags=\" \".join(args),\n        IsActive=True,\n        ImageFilename=\"execOnce.file\",\n        ImageDir=\"&lt;SceneFolder&gt;\",\n        ImageExtension=\"\",\n        ImagePreNumberLetter=\"\",\n        SceneOS=get_rr_platform(),\n        rrEnvList=environment_serialized,\n        CustomSHotName=jobname,\n        CompanyProjectName=instance.context.data[\"projectName\"],\n        SubmitterParameters=submitter_parameters_job\n    )\n\n    # add assembly jobs as dependencies\n    if instance.data.get(\"tileRendering\"):\n        self.log.info(\"Adding tile assembly jobs as dependencies...\")\n        job.WaitForPreIDs += instance.data.get(\"assemblySubmissionJobs\")\n    elif instance.data.get(\"bakingSubmissionJobs\"):\n        self.log.info(\"Adding baking submission jobs as dependencies...\")\n        job.WaitForPreIDs += instance.data[\"bakingSubmissionJobs\"]\n    else:\n        job.WaitForPreIDs += jobs_pre_ids\n\n    return job\n</code></pre>"},{"location":"autoapi/client/ayon_royalrender/plugins/publish/submit_jobs_to_royalrender.html","title":"submit_jobs_to_royalrender","text":"<p>Submit jobs to RoyalRender.</p>"},{"location":"autoapi/client/ayon_royalrender/plugins/publish/submit_jobs_to_royalrender.html#client.ayon_royalrender.plugins.publish.submit_jobs_to_royalrender.SubmitJobsToRoyalRender","title":"<code>SubmitJobsToRoyalRender</code>","text":"<p>               Bases: <code>ContextPlugin</code></p> <p>Find all jobs, create submission XML and submit it to RoyalRender.</p> Source code in <code>client/ayon_royalrender/plugins/publish/submit_jobs_to_royalrender.py</code> <pre><code>class SubmitJobsToRoyalRender(pyblish.api.ContextPlugin):\n    \"\"\"Find all jobs, create submission XML and submit it to RoyalRender.\"\"\"\n    label = \"Submit jobs to RoyalRender\"\n    order = pyblish.api.IntegratorOrder + 0.3\n    targets = [\"local\"]\n\n    def __init__(self):\n        super(SubmitJobsToRoyalRender, self).__init__()\n        self._rr_root = None\n        self._rr_api = None\n        self._submission_parameters = []\n\n    def process(self, context):\n\n        # iterate over all instances and try to find RRJobs\n        jobs = []\n        auto_delete = False\n        instance_rr_path = None\n        for instance in context:\n            if not instance.data.get(\"farm\"):\n                self.log.info(\"Skipping local instance.\")\n                continue\n            if isinstance(instance.data.get(\"rrJob\"), RRJob):\n                jobs.append(instance.data.get(\"rrJob\"))\n            if instance.data.get(\"rrJobs\"):\n                if all(\n                        isinstance(job, RRJob)\n                        for job in instance.data.get(\"rrJobs\")):\n                    jobs += instance.data.get(\"rrJobs\")\n            if instance.data.get(\"rr_root\"):\n                instance_rr_path = instance.data[\"rr_root\"]\n            if instance.data.get(\"auto_delete\"):\n                #GlobalSubmissionParameter\n                auto_delete=instance.data[\"auto_delete\"]\n\n\n        if jobs:\n            self._rr_root = instance_rr_path\n            if not self._rr_root:\n                raise KnownPublishError(\n                    (\"Missing RoyalRender root. \"\n                     \"You need to configure RoyalRender module.\"))\n            self._rr_api = rrApi(self._rr_root)\n            self._submission_parameters = self.get_submission_parameters(auto_delete)\n            self.process_submission(jobs)\n            return\n\n        self.log.info(\"No RoyalRender jobs found\")\n\n    def process_submission(self, jobs):\n        # type: ([RRJob]) -&gt; None\n\n        idx_pre_id = 0\n        for job in jobs:\n            job.PreID = idx_pre_id\n            if idx_pre_id &gt; 0:\n                job.WaitForPreIDs.append(idx_pre_id - 1)\n                # adjust rr pre id for publish job\n                if job.SceneName.endswith(\"metadata.json\"):\n                    idx_pre_id =+ 10\n            idx_pre_id += 1\n\n        submission = rrApi.create_submission(\n            jobs,\n            self._submission_parameters)\n\n        xml = tempfile.NamedTemporaryFile(suffix=\".xml\", delete=False)\n        with open(xml.name, \"w\") as f:\n            f.write(submission.serialize())\n\n        self.log.info(\"submitting job(s) file: {}\".format(xml.name))\n        self._rr_api.submit_file(file=xml.name)\n\n    def create_file(self, name, ext, contents=None):\n        temp = tempfile.NamedTemporaryFile(\n            dir=self.tempdir,\n            suffix=ext,\n            prefix=name + '.',\n            delete=False,\n        )\n\n        if contents:\n            with open(temp.name, 'w') as f:\n                f.write(contents)\n\n        return temp.name\n\n    def get_submission_parameters(self, auto_delete):\n        if auto_delete:\n            return [\n                SubmitterParameter(\"RequiredMemory\", \"0\"),\n                SubmitterParameter(\"PPAyoninjectenvvar\", \"1~1\"),\n                SubmitterParameter(\"-AutoDeleteEnabled\")\n            ]\n        return [\n            SubmitterParameter(\"RequiredMemory\", \"0\"),\n            SubmitterParameter(\"PPAyoninjectenvvar\", \"1~1\")\n        ]\n</code></pre>"},{"location":"autoapi/client/ayon_royalrender/rr_root/index.html","title":"rr_root","text":""},{"location":"autoapi/client/ayon_royalrender/rr_root/render_apps/index.html","title":"render_apps","text":""},{"location":"autoapi/client/ayon_royalrender/rr_root/render_apps/scripts/index.html","title":"scripts","text":""},{"location":"autoapi/client/ayon_royalrender/rr_root/render_apps/scripts/ayon_inject_envvar.html","title":"ayon_inject_envvar","text":""},{"location":"autoapi/client/ayon_royalrender/rr_root/render_apps/scripts/ayon_inject_envvar.html#client.ayon_royalrender.rr_root.render_apps.scripts.ayon_inject_envvar.InjectEnvironment","title":"<code>InjectEnvironment</code>","text":"<p>Creates rrEnv file.</p> <p>RR evnList has limitation on 2000 characters, which might not be enough. This script should be triggered by render jobs that were published from Ayon, it uses .json metadata to parse context and required Ayon launch environments to generate environment variable file for particular context.</p> <p>This file is converted into rrEnv file.</p> <p>Render job already points to non-existent location which got filled only by this process. (Couldn't figure way how to attach new file to existing job.)</p> <p>Expected set environments on RR worker: - AYON_SERVER_URL - AYON_API_KEY - API key to Ayon server, most likely from service account - AYON_EXECUTABLE - locally accessible path for <code>ayon_console</code> (could be removed if it would be possible to have it in renderApps config and to be accessible from there as there it is required for publish jobs). - AYON_FILTER_ENVIRONMENTS - potential black list of unwanted environment variables (separated by ';') - will be filtered out from created .rrEnv.</p> <p>Ayon submission job must be adding this line to .xml submission file: PPAyoninjectenvvar=1~1</p> <p>Scripts logs into folder with metadata json - could be removed if there is a way how to log into RR output.</p> Source code in <code>client/ayon_royalrender/rr_root/render_apps/scripts/ayon_inject_envvar.py</code> <pre><code>class InjectEnvironment:\n    \"\"\"Creates rrEnv file.\n\n    RR evnList has limitation on 2000 characters, which might not be enough.\n    This script should be triggered by render jobs that were published from\n    Ayon, it uses .json metadata to parse context and required Ayon launch\n    environments to generate environment variable file for particular context.\n\n    This file is converted into rrEnv file.\n\n    Render job already points to non-existent location which got filled only\n    by this process. (Couldn't figure way how to attach new file to existing\n    job.)\n\n    Expected set environments on RR worker:\n    - AYON_SERVER_URL\n    - AYON_API_KEY - API key to Ayon server, most likely from service account\n    - AYON_EXECUTABLE - locally accessible path for `ayon_console`\n    (could be removed if it would be possible to have it in renderApps config\n    and to be accessible from there as there it is required for publish jobs).\n    - AYON_FILTER_ENVIRONMENTS - potential black list of unwanted environment\n    variables (separated by ';') - will be filtered out from created .rrEnv.\n\n    Ayon submission job must be adding this line to .xml submission file:\n    &lt;SubmitterParameter&gt;PPAyoninjectenvvar=1~1&lt;/SubmitterParameter&gt;\n\n    Scripts logs into folder with metadata json - could be removed if there\n    is a way how to log into RR output.\n\n    \"\"\"\n\n    def __init__(self):\n        self.meta_dir = None\n        self.tcp = self.tcp_connect()\n        self.job = self._get_job()\n\n    def tcp_connect(self):\n        tcp = rr_connect.server_connect(user_name=None)\n        tcp.configGetGlobal()\n        if tcp.errorMessage():\n            print(tcp.errorMessage())\n            raise ConnectionError(tcp.errorMessage())\n        return tcp\n\n    def inject(self):\n        # TODO logging only in RR not to file?\n        logs.append(\"InjectEnvironment starting\")\n        meta_dir = self._get_metadata_dir()\n        self.meta_dir = meta_dir\n        envs = self._get_job_environments()\n\n        if not envs.get(\"AYON_RENDER_JOB\"):\n            logs.append(\"Not a ayon render job, skipping.\")\n            return\n\n        self._check_launch_environemnt()\n\n        context = self._get_context()\n\n        logs.append(\"context {}\".format(context))\n        executable = self._get_executable()\n\n        logs.append(\"executable {}\".format(executable))\n\n        extracted_env = self._extract_environments(executable, context)\n\n        rrEnv_path = self._create_rrEnv(meta_dir, extracted_env)\n        print(f\"Ayon job environment exported to rrEnv file:\\n{rrEnv_path}\")\n        logs.append(f\"InjectEnvironment ending, rrEnv file {rrEnv_path}\")\n\n    def _get_metadata_dir(self):\n        \"\"\"Get folder where metadata.json and renders should be produced.\"\"\"\n        new_path = self.job.imageDir\n\n        logs.append(f\"_get_metadata_dir::{new_path}\")\n        return new_path\n\n    def _check_launch_environemnt(self):\n        required_envs = [\"AYON_SERVER_URL\", \"AYON_API_KEY\", \"AYON_EXECUTABLE\"]\n        missing = []\n        for key in required_envs:\n            if not os.environ.get(key):\n                missing.append(key)\n\n        if missing:\n            msg = (\n                f\"Required environment variable missing: '{','.join(missing)}\"\n            )\n            logs.append(msg)\n            raise RuntimeError(msg)\n\n    def _get_context(self):\n        envs = self._get_job_environments()\n        return {\n            \"project\": envs[\"AYON_PROJECT_NAME\"],\n            \"folder\": envs[\"AYON_FOLDER_PATH\"],\n            \"task\": envs[\"AYON_TASK_NAME\"],\n            \"app\": envs[\"AYON_APP_NAME\"],\n            \"envgroup\": \"farm\",\n        }\n\n    def _get_job(self):\n        logs.append(\"get_jobs\")\n        parser = argparse.ArgumentParser()\n        parser.add_argument(\"-jid\")\n        parser.add_argument(\n            \"filepath\",\n            help=\"Where script file with environment will be saved\"\n        )\n        args = parser.parse_args()\n\n        jid = int(args.jid)\n        if not self.tcp.jobList_GetInfo(jid):\n            msg = \"Error jobList_GetInfo: \" + self.tcp.errorMessage()\n            print(msg)\n            raise RuntimeError(msg)\n        job = self.tcp.jobs.getJobSend(jid)\n        self.tcp.jobs.setPathTargetOS(job.sceneOS)\n\n        return job\n\n    def _get_job_environments(self):\n        \"\"\"Gets environments set on job.\n\n        It seems that it is not possible to query \"rrEnvList\" on job directly,\n        it must be parsed from .json document.\n        \"\"\"\n        job = self._get_job()\n        env_list = job.customData_Str(\"rrEnvList\")\n        envs = {}\n        for env in env_list.split(\"~~~\"):\n            if \"=\" in env:\n                key, value = env.split(\"=\", 1)\n                envs[key] = value\n\n        return envs\n\n    def _get_executable(self):\n        # rr_python_utils.cache.get_rr_bin_folder()  # TODO maybe useful\n        return os.environ[\"AYON_EXECUTABLE\"]\n\n    def _get_launch_environments(self):\n        \"\"\"Enhances environemnt with required for Ayon to be launched.\"\"\"\n        job_envs = self._get_job_environments()\n        ayon_environment = {\n            \"AYON_SERVER_URL\": os.environ[\"AYON_SERVER_URL\"],\n            \"AYON_API_KEY\": os.environ[\"AYON_API_KEY\"],\n            \"AYON_BUNDLE_NAME\": job_envs[\"AYON_BUNDLE_NAME\"],\n        }\n        logs.append(\"Ayon launch environments:: {}\".format(ayon_environment))\n        environment = os.environ.copy()\n        environment.update(ayon_environment)\n        return environment\n\n    def _get_export_path(self):\n        \"\"\"Returns unique path with extracted env variables from Ayon.\"\"\"\n        temp_file_name = \"{}_{}.json\".format(\n            datetime.utcnow().strftime(\"%Y%m%d%H%M%S%f\"), str(uuid.uuid1())\n        )\n        export_url = os.path.join(tempfile.gettempdir(), temp_file_name)\n        return export_url\n\n    def _extract_environments(self, executable, context):\n        # tempfile.TemporaryFile cannot be used because of locking\n        export_path = self._get_export_path()\n\n        args = [\n            executable,\n            \"--headless\",\n            \"addon\",\n            \"applications\",\n            \"extractenvironments\",\n            export_path\n        ]\n\n        if all(context.values()):\n            for key, value in context.items():\n                args.extend([\"--{}\".format(key), value])\n\n        environments = self._get_launch_environments()\n\n        logs.append(\"Running:: {}\".format(args))\n        proc = subprocess.Popen(\n            args,\n            env=environments,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n        )\n        output, error = proc.communicate()\n\n        if not os.path.exists(export_path):\n            logs.append(\"output::{}\".format(output))\n            logs.append(\"error::{}\".format(error))\n            raise RuntimeError(\"Extract failed with {}\".format(error))\n\n        with open(export_path) as json_file:\n            return json.load(json_file)\n\n    def _create_rrEnv(self, meta_dir, extracted_env):\n        \"\"\"Create rrEnv.rrEnv file in metadata folder that render job points\"\"\"\n        filter_out = os.environ.get(\"AYON_FILTER_ENVIRONMENTS\")\n        filter_envs = set()\n        if filter_out:\n            filter_envs = set(filter_out.split(\";\"))\n\n        lines = []\n        platform_name = platform.system().lower()\n        if platform_name == \"windows\":\n            env_command = \"set\"\n            ext = \"bat\"\n        else:\n            env_command = \"export\"\n            ext = \"sh\"\n\n        platform_deny_name = f\"env_denied_{platform_name}\"\n        platform_deny_list = env_denied_dict[platform_deny_name]\n        denied: set[str] = set(platform_deny_list)\n        denied.update(env_denied_dict[\"env_denied_RR\"])\n        for key, value in extracted_env.items():\n            if key in filter_envs:\n                continue\n            if key in denied:\n                continue\n\n            line = f\"{env_command} {key}={value}\"\n            lines.append(line)\n\n        rrenv_path = os.path.join(meta_dir, f\"rrEnv.{ext}\")\n\n        with open(rrenv_path, \"w\") as fp:\n            fp.writelines(s + \"\\n\" for s in lines)\n\n        return os.path.normpath(rrenv_path)\n</code></pre>"},{"location":"autoapi/client/ayon_royalrender/rr_root/render_apps/scripts/ayon_remote_publish.html","title":"ayon_remote_publish","text":""},{"location":"autoapi/server/index.html","title":"server","text":""},{"location":"autoapi/server/settings.html","title":"settings","text":""}]}